Directory structure:
└── trainnect-dev-v47-trainnect-ai/
    ├── README.md
    ├── babel.config.test.js
    ├── components.json
    ├── eslint.config.mjs
    ├── jest.config.js
    ├── jest.setup.js
    ├── next.config.ts
    ├── package.json
    ├── postcss.config.mjs
    ├── tailwind.config.ts
    ├── test-openai.sh
    ├── test.txt
    ├── tsconfig.json
    ├── __mocks__/
    │   ├── fileMock.js
    │   ├── framer-motion.js
    │   ├── react-markdown.js
    │   ├── @ai-sdk/
    │   │   └── react.js
    │   └── lib/
    │       ├── models.js
    │       └── posthog.js
    ├── app/
    │   ├── globals.css
    │   ├── layout.tsx
    │   ├── page.tsx
    │   ├── providers.tsx
    │   ├── admin/
    │   │   └── prompts/
    │   │       └── page.tsx
    │   ├── ai-agents/
    │   │   └── page.tsx
    │   ├── api/
    │   │   ├── ai-agents/
    │   │   │   └── route.ts
    │   │   ├── chat/
    │   │   │   ├── route.ts
    │   │   │   └── history/
    │   │   │       ├── route.ts
    │   │   │       └── [conversationId]/
    │   │   │           └── route.ts
    │   │   ├── prompts/
    │   │   │   └── route.ts
    │   │   ├── tavily-chat/
    │   │   │   └── route.ts
    │   │   └── tavily-search/
    │   │       └── route.ts
    │   ├── chat-history/
    │   │   └── page.tsx
    │   └── tavily-ai-search/
    │       └── page.tsx
    ├── components/
    │   ├── chat.tsx
    │   ├── deploy-button.tsx
    │   ├── footnote.tsx
    │   ├── icons.tsx
    │   ├── input.tsx
    │   ├── markdown-components.tsx
    │   ├── messages.tsx
    │   ├── model-selector.tsx
    │   ├── navigation.tsx
    │   ├── sidebar.tsx
    │   ├── star-button.tsx
    │   ├── tavily-chat.tsx
    │   ├── ai-agents/
    │   │   └── agent-chat.tsx
    │   ├── prompt-manager/
    │   │   └── prompt-editor.tsx
    │   └── ui/
    │       ├── badge.tsx
    │       ├── button.tsx
    │       ├── card.tsx
    │       ├── select.tsx
    │       ├── sonner.tsx
    │       └── textarea.tsx
    ├── lib/
    │   ├── models.ts
    │   ├── utils.ts
    │   ├── __tests__/
    │   │   ├── api.test.ts
    │   │   ├── models.test.ts
    │   │   ├── tavily-chat.test.ts
    │   │   └── tavily-search.test.ts
    │   ├── ai-agents/
    │   │   ├── types.ts
    │   │   └── utils.ts
    │   ├── config/
    │   │   └── prompts.ts
    │   ├── db/
    │   │   ├── index.ts
    │   │   └── server.ts
    │   └── services/
    │       └── prompt-manager.ts
    ├── public/
    ├── scripts/
    │   ├── run-all-tests.sh
    │   └── test-models.js
    ├── tests/
    │   ├── multimodal.test.tsx
    │   └── tavily-chat.test.tsx
    ├── tools/
    │   ├── README.md
    │   └── tavily-search.ts
    └── utils/
        ├── ai-agents-logger.ts
        └── tavily-logger.ts


================================================
File: components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


================================================
File: eslint.config.mjs
================================================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;

================================================
File: next.config.ts
================================================
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  transpilePackages: ['geist'],
  images: {
    remotePatterns: [
      {
        hostname: 'vercel.com',
      },
    ],
  },
};

export default nextConfig;



================================================
File: package.json
================================================
{
  "name": "v2-trainnect-ai-reasoning-no-auth",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:models": "node scripts/test-models.js",
    "test:all": "./scripts/run-all-tests.sh"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "1.1.17",
    "@ai-sdk/google": "^1.1.25",
    "@ai-sdk/groq": "1.1.14",
    "@ai-sdk/mistral": "1.1.17",
    "@ai-sdk/openai": "1.2.5",
    "@ai-sdk/perplexity": "1.0.6",
    "@ai-sdk/react": "1.1.23",
    "@openrouter/ai-sdk-provider": "^0.4.3",
    "@radix-ui/react-select": "^2.1.6",
    "@radix-ui/react-slot": "^1.1.2",
    "@shadcn/ui": "^0.0.4",
    "@tavily/core": "^0.3.1",
    "@testing-library/react": "^16.2.0",
    "ai": "4.1.61",
    "better-sqlite3": "^11.9.1",
    "class-variance-authority": "^0.7.1",
    "classnames": "^2.5.1",
    "clsx": "^2.1.1",
    "framer-motion": "^12.5.0",
    "geist": "^1.3.1",
    "lucide-react": "^0.482.0",
    "next": "15.2.2",
    "next-themes": "^0.4.6",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-markdown": "^10.1.0",
    "sonner": "^2.0.1",
    "tailwind-merge": "^3.0.2",
    "tailwindcss-animate": "^1.0.7",
    "uuid": "^11.1.0",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@babel/preset-env": "^7.26.9",
    "@babel/preset-react": "^7.26.3",
    "@babel/preset-typescript": "^7.26.0",
    "@eslint/eslintrc": "^3.3.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@types/better-sqlite3": "^7.6.12",
    "@types/jest": "^29.5.14",
    "@types/node": "^20",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "@types/uuid": "^10.0.0",
    "babel-jest": "^29.7.0",
    "dotenv": "^16.4.7",
    "eslint": "^9.22.0",
    "eslint-config-next": "15.2.2",
    "identity-obj-proxy": "^3.0.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "postcss": "^8.5.3",
    "tailwindcss": "^3.4.1",
    "ts-jest": "^29.2.6",
    "typescript": "^5.8.0"
  },
  "packageManager": "pnpm@10.4.0+sha512.6b849d0787d97f8f4e1f03a9b8ff8f038e79e153d6f11ae539ae7c435ff9e796df6a862c991502695c7f9e8fac8aeafc1ac5a8dab47e36148d183832d886dd52",
  "pnpm": {
    "onlyBuiltDependencies": [
      "better-sqlite3",
      "core-js",
      "sharp"
    ]
  }
}



================================================
File: postcss.config.mjs
================================================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;



================================================
File: tailwind.config.ts
================================================
import type { Config } from "tailwindcss";

export default {
    darkMode: ["class"],
    content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		fontFamily: {
  			sans: [
  				'var(--font-geist-sans)'
  			],
  			mono: [
  				'var(--font-geist-mono)'
  			]
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;



================================================
File: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


================================================
File: app/globals.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;



@layer base {
  :root {

    --background: 0 0% 100%;

    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;

    --card-foreground: 222.2 84% 4.9%;

    --popover: 0 0% 100%;

    --popover-foreground: 222.2 84% 4.9%;

    --primary: 222.2 47.4% 11.2%;

    --primary-foreground: 210 40% 98%;

    --secondary: 210 40% 96.1%;

    --secondary-foreground: 222.2 47.4% 11.2%;

    --muted: 210 40% 96.1%;

    --muted-foreground: 215.4 16.3% 46.9%;

    --accent: 210 40% 96.1%;

    --accent-foreground: 222.2 47.4% 11.2%;

    --destructive: 0 84.2% 60.2%;

    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;

    --input: 214.3 31.8% 91.4%;

    --ring: 222.2 84% 4.9%;

    --chart-1: 12 76% 61%;

    --chart-2: 173 58% 39%;

    --chart-3: 197 37% 24%;

    --chart-4: 43 74% 66%;

    --chart-5: 27 87% 67%;

    --radius: 0.5rem
  }
  .dark {

    --background: 222.2 84% 4.9%;

    --foreground: 210 40% 98%;

    --card: 222.2 84% 4.9%;

    --card-foreground: 210 40% 98%;

    --popover: 222.2 84% 4.9%;

    --popover-foreground: 210 40% 98%;

    --primary: 210 40% 98%;

    --primary-foreground: 222.2 47.4% 11.2%;

    --secondary: 217.2 32.6% 17.5%;

    --secondary-foreground: 210 40% 98%;

    --muted: 217.2 32.6% 17.5%;

    --muted-foreground: 215 20.2% 65.1%;

    --accent: 217.2 32.6% 17.5%;

    --accent-foreground: 210 40% 98%;

    --destructive: 0 62.8% 30.6%;

    --destructive-foreground: 210 40% 98%;

    --border: 217.2 32.6% 17.5%;

    --input: 217.2 32.6% 17.5%;

    --ring: 212.7 26.8% 83.9%;

    --chart-1: 220 70% 50%;

    --chart-2: 160 60% 45%;

    --chart-3: 30 80% 55%;

    --chart-4: 280 65% 60%;

    --chart-5: 340 75% 55%
  }
}



@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}



================================================
File: app/layout.tsx
================================================
import { Toaster } from 'sonner';
import { GeistSans } from 'geist/font/sans';
import { GeistMono } from 'geist/font/mono';
import type { Metadata } from 'next';
import { Sidebar, SidebarBody, SidebarLinks } from '@/components/sidebar';
import { Providers } from './providers';

import './globals.css';

export const metadata: Metadata = {
  title: 'AI-Reasoning',
  description:
    'Trainnect-AI-Reasoning.',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className={`${GeistSans.variable} ${GeistMono.variable}`} suppressHydrationWarning>
      <body className="min-h-screen dark:bg-gray-950">
        <Providers>
        <Toaster position="top-center" />
        <div className="flex">
          <Sidebar>
            <SidebarBody>
              <SidebarLinks />
            </SidebarBody>
          </Sidebar>
          <main className="flex-1 p-4 md:p-8">
            {children}
          </main>
        </div>
        </Providers>
      </body>
    </html>
  );
}



================================================
File: app/page.tsx
================================================
import { Chat } from "@/components/chat";

export default function Home() {
  return (
    <div className="flex flex-col size-full items-center">
      <Chat />
    </div>
  );
}



================================================
File: app/providers.tsx
================================================
'use client';

import { ThemeProvider } from 'next-themes';

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
      {children}
    </ThemeProvider>
  );
}



================================================
File: app/admin/prompts/page.tsx
================================================
'use client';

import { PromptEditor } from '@/components/prompt-manager/prompt-editor';
import { Toaster } from '@/components/ui/sonner';

export default function PromptsPage() {
  return (
    <div className="container mx-auto py-8">
      <h1 className="text-3xl font-semibold mb-6">Prompt Management</h1>
      <Toaster />
      <PromptEditor />
    </div>
  );
}



================================================
File: app/ai-agents/page.tsx
================================================
import { AgentChat } from '@/components/ai-agents/agent-chat';

export default function AIAgentsPage() {
  return (
    <div className="container mx-auto">
      <div className="mb-6">
        <h1 className="text-2xl font-bold mb-2">AI Agents</h1>
        <p className="text-muted-foreground">
          Multi-step AI processing with model switching. The primary model handles research using
          Tavily search, while the secondary model processes and refines the results.
        </p>
      </div>
      <AgentChat />
    </div>
  );
}



================================================
File: app/api/ai-agents/route.ts
================================================
import { createDataStreamResponse, streamText, tool } from 'ai';
import { z } from 'zod';
import { getModelInstance } from '@/lib/ai-agents/utils';
import type { ModelConfig } from '@/lib/ai-agents/types';
import { searchTavily } from "@/tools/tavily-search";
import { aiAgentsLogger } from '@/utils/ai-agents-logger';
import { promptManager } from '@/lib/services/prompt-manager';
import type { Message } from "@/lib/db";
import { stmts } from "@/lib/db/server";
import { v4 as uuidv4 } from "uuid";

export async function POST(req: Request) {
  const { messages, primaryModel, secondaryModel, conversationId = uuidv4() } = await req.json();
  const timestamp = new Date().toISOString();
  const query = messages[messages.length - 1].content;

  // Store user message
  const userMessage = messages[messages.length - 1];
  const message: Message = {
    id: uuidv4(),
    role: userMessage.role,
    content: userMessage.content,
    timestamp: Date.now(),
    conversation_id: conversationId,
    chat_type: 'ai-agent',
    metadata: JSON.stringify({
      primaryModel,
      secondaryModel,
    })
  };
  stmts.insertMessage.run(
    message.id,
    message.role,
    message.content,
    message.timestamp,
    message.conversation_id,
    message.chat_type,
    message.metadata
  );

  return createDataStreamResponse({
    execute: async dataStream => {
      try {
        // Get all previous messages except the last one (which is the new query)
        const previousMessages = messages.slice(0, -1);
        const newMessage = messages[messages.length - 1];

        // Step 1: Research with primary model and Tavily search
        const result1 = streamText({
          model: getModelInstance(primaryModel as ModelConfig),
          system: promptManager.compilePrompt('aiAgent', {
            SEARCH_DEPTH: 'advanced',
            RESPONSE_STYLE: 'concise'
          }),
          messages: [...previousMessages, newMessage], // Include conversation history
          toolChoice: 'required',
          tools: {
            tavily: tool({
              parameters: z.object({ query: z.string() }),
              execute: async ({ query }) => {
                const tavilyPrompt = promptManager.getPrompt('tavily-chat');
                const results = await searchTavily({ 
                  query,
                  searchDepth: tavilyPrompt?.tavilySettings?.searchDepth || "advanced",
                  maxResults: tavilyPrompt?.tavilySettings?.maxResults || 5,
                  includeAnswer: tavilyPrompt?.tavilySettings?.includeAnswer ?? true,
                  includeRawContent: tavilyPrompt?.tavilySettings?.includeRawContent ?? false,
                  includeDomains: tavilyPrompt?.tavilySettings?.includeDomains,
                  excludeDomains: tavilyPrompt?.tavilySettings?.excludeDomains,
                });
                return JSON.stringify(results);
              },
            }),
          },
        });

        // Forward initial result without finish event
        result1.mergeIntoDataStream(dataStream, {
          experimental_sendFinish: false,
        });

        const primaryResults = await result1.response;

        // Store primary model's response
        const primaryMessage: Message = {
          id: uuidv4(),
          role: 'assistant',
          content: String(primaryResults.messages[primaryResults.messages.length - 1].content),
          timestamp: Date.now(),
          conversation_id: conversationId,
          chat_type: 'ai-agent',
          metadata: JSON.stringify({
            model: primaryModel,
            phase: 'research',
            toolCalls: (primaryResults.messages[primaryResults.messages.length - 1] as any).toolCalls || []
          })
        };
        stmts.insertMessage.run(
          primaryMessage.id,
          primaryMessage.role,
          primaryMessage.content,
          primaryMessage.timestamp,
          primaryMessage.conversation_id,
          primaryMessage.chat_type,
          primaryMessage.metadata
        );

        // Step 2: Process results with secondary model
        const result2 = streamText({
          model: getModelInstance(secondaryModel as ModelConfig),
          system: promptManager.compilePrompt('aiAgentProcessor', {
            ANALYSIS_DEPTH: 'comprehensive',
            OUTPUT_FORMAT: 'structured'
          }),
          messages: [
            ...previousMessages,
            {
              role: 'assistant',
              content: 'Here is the research information: ' + primaryResults.messages[primaryResults.messages.length - 1].content
            },
            newMessage
          ],
        });

        // Forward second result (including finish event)
        result2.mergeIntoDataStream(dataStream, {
          experimental_sendStart: false,
        });

        const secondaryResults = await result2.response;

        // Store secondary model's response
        const secondaryMessage: Message = {
          id: uuidv4(),
          role: 'assistant',
          content: String(secondaryResults.messages[secondaryResults.messages.length - 1].content),
          timestamp: Date.now(),
          conversation_id: conversationId,
          chat_type: 'ai-agent',
          metadata: JSON.stringify({
            model: secondaryModel,
            phase: 'processing'
          })
        };
        stmts.insertMessage.run(
          secondaryMessage.id,
          secondaryMessage.role,
          secondaryMessage.content,
          secondaryMessage.timestamp,
          secondaryMessage.conversation_id,
          secondaryMessage.chat_type,
          secondaryMessage.metadata
        );

        // Log both models' results
        await aiAgentsLogger.logProcessing({
          timestamp,
          query,
          primaryModel,
          secondaryModel,
          primaryResults,
          secondaryResults
        });
      } catch (error) {
        console.error('Error in AI Agents processing:', error);
        throw error;
      }
    },
  });
}



================================================
File: app/api/chat/route.ts
================================================
import { myProvider, modelApiNames } from "@/lib/models";
import { Message, smoothStream, streamText } from "ai";
import { NextRequest } from "next/server";
import { promptManager } from '@/lib/services/prompt-manager';
import type { Message as DBMessage } from "@/lib/db";
import { stmts } from "@/lib/db/server";
import { v4 as uuidv4 } from "uuid";

export async function POST(request: NextRequest) {
  const {
    messages,
    selectedModelId,
    isReasoningEnabled,
    conversationId = uuidv4(),
  }: {
    messages: Array<Message>;
    selectedModelId: string;
    isReasoningEnabled: boolean;
    conversationId?: string;
  } = await request.json();

  // Store incoming user message
  const userMessage = messages[messages.length - 1];
  if (userMessage.role === 'user') {
    const dbMessage: DBMessage = {
      id: uuidv4(),
      role: userMessage.role,
      content: userMessage.content,
      timestamp: Date.now(),
      conversation_id: conversationId,
      chat_type: 'chat'
    };
    stmts.insertMessage.run(
      dbMessage.id,
      dbMessage.role,
      dbMessage.content,
      dbMessage.timestamp,
      dbMessage.conversation_id,
      dbMessage.chat_type,
      dbMessage.metadata
    );
  }

  // Check if messages contain PDF or image attachments
  const messagesHavePDF = messages.some(message =>
    message.experimental_attachments?.some(
      a => a.contentType === 'application/pdf',
    ),
  );
  
  const messagesHaveImage = messages.some(message =>
    message.experimental_attachments?.some(
      a => a.contentType?.startsWith('image/'),
    ),
  );

  // Configure provider-specific options based on the selected model
  const providerOptions: Record<string, any> = {};
  
  // Default to Claude 3.7 Sonnet if no model is selected
  let modelId = selectedModelId || "claude-3.7-sonnet";
  
  // Override model selection for multimodal content if needed
  if (messagesHavePDF) {
    // For PDFs, Claude, GPT-4o, and Gemini all support PDFs
    if (!modelId.startsWith("gemini")) {
      modelId = "gemini-2.0-flash";
    }
  } else if (messagesHaveImage) {
    // For images, ensure we're using a model that supports image input
    // Claude, OpenAI, and Gemini all support images
    if (!modelId.startsWith("gemini") && !modelId.startsWith("o3") && !modelId.startsWith("gemini")) {
      modelId = "gemini-2.0-flash";
    }
  }
  
  // Get the API model name for the selected model ID
  const apiModelName = modelApiNames[modelId];
  
  if (!apiModelName) {
    console.error(`No API model name found for model ID: ${modelId}`);
    return new Response(
      JSON.stringify({
        error: `Invalid model ID: ${modelId}. Please select a valid model.`
      }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }
  
  // Configure provider-specific options based on the selected model
  if (modelId.startsWith("claude")) {
    providerOptions.anthropic = {
      thinking: {
        type: isReasoningEnabled ? "enabled" : "disabled",
        budgetTokens: 12000,
      },
      model: apiModelName,
    };
  } else if (modelId.startsWith("o3")) {
    providerOptions.openai = {
      temperature: 0.2,
      model: "o3-mini", // Use the exact model name
    };
  } else if (modelId.startsWith("gemini")) {
    providerOptions.google = {
      temperature: 0.2,
      model: apiModelName,
    };
  } else if (modelId.includes("qwen")) {
    providerOptions.groq = {
      temperature: 0.2,
      model: apiModelName,
    };
  } else if (modelId.includes("codestral")) {
    providerOptions.mistral = {
      temperature: 0.2,
      model: apiModelName,
    };
  } else if (modelId.includes("perplexity")) {
    providerOptions.perplexity = {
      temperature: 0.2,
      model: apiModelName,
    };
  } else if (modelId.includes("google/gemini-2.0-flash-thinking-exp:free")) {
    providerOptions.openrouter = {
      temperature: 0.2,
      model: apiModelName,
    };
  }

  try {
    console.log(`Attempting to use model: ${modelId} with options:`, providerOptions);
    
    // Get base prompt and add multimodal context if needed
    let systemPrompt = promptManager.compilePrompt('mainChat', {
      MODEL_ID: modelId,
      USER_ROLE: 'AI and machine learning research',
      EXPERTISE_LEVEL: 'advanced'
    });
    
    if (messagesHavePDF) {
      systemPrompt += promptManager.compilePrompt('pdfContext');
    } else if (messagesHaveImage) {
      systemPrompt += promptManager.compilePrompt('imageContext');
    }
    
    const stream = streamText({
      system: systemPrompt,
      providerOptions,
      model: myProvider.languageModel(modelId),
      experimental_transform: [
        smoothStream({
          chunking: "word",
        }),
      ],
      messages,
    });

    const response = stream.toDataStreamResponse({
      sendReasoning: true,
      getErrorMessage: (error) => {
        console.error(`Error with model ${modelId}:`, error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        return `An error occurred with ${modelId}: ${errorMessage}. Please try again or select a different model.`;
      },
    });

    // Store assistant's response
    response.clone().text().then(text => {
      try {
        const assistantMessage: DBMessage = {
          id: uuidv4(),
          role: 'assistant',
          content: text,
          timestamp: Date.now(),
          conversation_id: conversationId,
          chat_type: 'chat'
        };
        stmts.insertMessage.run(
          assistantMessage.id,
          assistantMessage.role,
          assistantMessage.content,
          assistantMessage.timestamp,
          assistantMessage.conversation_id,
          assistantMessage.chat_type,
          assistantMessage.metadata
        );
      } catch (error) {
        console.error('Failed to store assistant message:', error);
      }
    });

    return response;
  } catch (error) {
    console.error(`Failed to stream with model ${modelId}:`, error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    return new Response(
      JSON.stringify({
        error: `Failed to initialize ${modelId}: ${errorMessage}. Please check your API keys and try again.`
      }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}



================================================
File: app/api/chat/history/route.ts
================================================
import type { ChatType } from '@/lib/db';
import { db, stmts } from '@/lib/db/server';
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const type = searchParams.get('type') as ChatType | 'all';

    const conversations = type === 'all' 
      ? stmts.getAllConversations.all()
      : stmts.getConversationsByType.all(type);

    return NextResponse.json({ conversations });
  } catch (error) {
    console.error('Error fetching chat history:', error);
    return NextResponse.json(
      { error: 'Failed to fetch chat history' },
      { status: 500 }
    );
  }
}



================================================
File: app/api/chat/history/[conversationId]/route.ts
================================================
import { stmts } from '@/lib/db/server';
import { NextRequest, NextResponse } from 'next/server';

type Props = {
  params: {
    conversationId: string;
  };
};

export async function GET(
  request: NextRequest,
  { params }: Props
) {
  try {
    const messages = stmts.getMessagesByConversation.all(params.conversationId);
    
    return NextResponse.json({ messages });
  } catch (error) {
    console.error('Failed to get chat history:', error);
    return NextResponse.json(
      { error: 'Failed to get chat history' },
      { status: 500 }
    );
  }
}



================================================
File: app/api/prompts/route.ts
================================================
import { promptManager } from '@/lib/services/prompt-manager';
import { NextResponse } from 'next/server';

export async function GET() {
  try {
    return NextResponse.json({ prompts: promptManager.getAllPrompts() });
  } catch (error) {
    return NextResponse.json({ error: 'Failed to fetch prompts' }, { status: 500 });
  }
}

export async function POST(req: Request) {
  try {
    const { id, config } = await req.json();
    
    if (!id || !config) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    promptManager.setPrompt(id, config);
    return NextResponse.json({ success: true });
  } catch (error) {
    return NextResponse.json({ error: 'Failed to update prompt' }, { status: 400 });
  }
}



================================================
File: app/api/tavily-chat/route.ts
================================================
import { myProvider, modelApiNames } from "@/lib/models";
import { Message, smoothStream, streamText } from "ai";
import { NextRequest } from "next/server";
import { searchTavily } from "@/tools/tavily-search";
import { promptManager } from '@/lib/services/prompt-manager';
import type { Message as DBMessage } from "@/lib/db";
import { stmts } from "@/lib/db/server";
import { v4 as uuidv4 } from "uuid";

export async function POST(request: NextRequest) {
  const {
    messages,
    selectedModelId,
    isReasoningEnabled,
    searchQuery,
    conversationId = uuidv4(),
  }: {
    messages: Array<Message>;
    selectedModelId: string;
    isReasoningEnabled: boolean;
    searchQuery?: string;
    conversationId?: string;
  } = await request.json();

  // Store incoming user message
  const userMessage = messages[messages.length - 1];
  if (userMessage.role === 'user') {
    const dbMessage: DBMessage = {
      id: uuidv4(),
      role: userMessage.role,
      content: userMessage.content,
      timestamp: Date.now(),
      conversation_id: conversationId,
      chat_type: 'ai-search',
      metadata: searchQuery ? JSON.stringify({ searchQuery }) : undefined
    };
    stmts.insertMessage.run(
      dbMessage.id,
      dbMessage.role,
      dbMessage.content,
      dbMessage.timestamp,
      dbMessage.conversation_id,
      dbMessage.chat_type,
      dbMessage.metadata
    );
  }

  // Check if messages contain PDF or image attachments
  const messagesHavePDF = messages.some(message =>
    message.experimental_attachments?.some(
      a => a.contentType === 'application/pdf',
    ),
  );
  
  const messagesHaveImage = messages.some(message =>
    message.experimental_attachments?.some(
      a => a.contentType?.startsWith('image/'),
    ),
  );

  // Configure provider-specific options based on the selected model
  const providerOptions: Record<string, any> = {};
  
  // Default to Claude 3.7 Sonnet if no model is selected
  let modelId = selectedModelId || "claude-3.7-sonnet";
  
  // Override model selection for multimodal content if needed
  if (messagesHavePDF) {
    // For PDFs, Claude, GPT-4o, and Gemini all support PDFs
    if (!modelId.startsWith("gemini")) {
      modelId = "gemini-2.0-flash";
    }
  } else if (messagesHaveImage) {
    // For images, ensure we're using a model that supports image input
    // Claude, GPT-4o, and Gemini all support images
    if (!modelId.startsWith("gemini") && !modelId.startsWith("o3") && !modelId.startsWith("gemini")) {
      modelId = "gemini-2.0-flash";
    }
  }
  
  // Get the API model name for the selected model ID
  const apiModelName = modelApiNames[modelId];
  
  if (!apiModelName) {
    console.error(`No API model name found for model ID: ${modelId}`);
    return new Response(
      JSON.stringify({
        error: `Invalid model ID: ${modelId}. Please select a valid model.`
      }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }
  
  // Configure provider-specific options based on the selected model
  if (modelId.startsWith("claude")) {
    providerOptions.anthropic = {
      thinking: {
        type: isReasoningEnabled ? "enabled" : "disabled",
        budgetTokens: 12000,
      },
      model: apiModelName,
    };
  } else if (modelId.startsWith("o3")) {
    providerOptions.openai = {
      temperature: 0.2,
      model: "o3-mini", // Use the exact model name
    };
  } else if (modelId.startsWith("gemini")) {
    providerOptions.google = {
      temperature: 0.2,
      model: apiModelName,
    };
  } else if (modelId.includes("qwen")) {
    providerOptions.groq = {
      temperature: 0.2,
      model: apiModelName,
    };
  } else if (modelId.includes("codestral")) {
    providerOptions.mistral = {
      temperature: 0.2,
      model: apiModelName,
    };
  } else if (modelId.includes("perplexity")) {
    providerOptions.perplexity = {
      temperature: 0.2,
      model: apiModelName,
    };
  } else if (modelId.includes("google/gemini-2.0-flash-thinking-exp:free")) {
    providerOptions.openrouter = {
      temperature: 0.2,
      model: apiModelName,
    };
  }

  try {
    console.log(`Attempting to use model: ${modelId} with options:`, providerOptions);
    
    // Get the Tavily prompt config and settings
    const tavilyPrompt = promptManager.getPrompt('tavily-chat');
    
    // Perform Tavily search if searchQuery is provided
    let searchResults = null;
    if (searchQuery) {
      try {
        searchResults = await searchTavily({
          query: searchQuery,
          searchDepth: tavilyPrompt?.tavilySettings?.searchDepth || "advanced",
          maxResults: tavilyPrompt?.tavilySettings?.maxResults || 5,
          includeAnswer: tavilyPrompt?.tavilySettings?.includeAnswer ?? true,
          includeRawContent: tavilyPrompt?.tavilySettings?.includeRawContent ?? false,
          includeDomains: tavilyPrompt?.tavilySettings?.includeDomains,
          excludeDomains: tavilyPrompt?.tavilySettings?.excludeDomains,
          modelId: modelId // Pass the model ID to track which model triggered the search
        });
        console.log("Tavily search results:", searchResults);
      } catch (error) {
        console.error("Error performing Tavily search:", error);
      }
    }
    
    // Get base prompt with context
    let systemPrompt = promptManager.compilePrompt('tavilyChat', {
      SEARCH_RESULTS: searchResults ? JSON.stringify(searchResults, null, 2) : '',
      SEARCH_DEPTH: 'advanced'
    });
    
    if (messagesHavePDF) {
      systemPrompt += promptManager.compilePrompt('pdfContext');
    } else if (messagesHaveImage) {
      systemPrompt += promptManager.compilePrompt('imageContext');
    }
    
    const stream = streamText({
      system: systemPrompt,
      providerOptions,
      model: myProvider.languageModel(modelId),
      experimental_transform: [
        smoothStream({
          chunking: "word",
        }),
      ],
      messages,
    });

    const response = stream.toDataStreamResponse({
      sendReasoning: true,
      getErrorMessage: (error) => {
        console.error(`Error with model ${modelId}:`, error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        return `An error occurred with ${modelId}: ${errorMessage}. Please try again or select a different model.`;
      },
    });

    // Store assistant's response with search results metadata
    response.clone().text().then(text => {
      try {
        const assistantMessage: DBMessage = {
          id: uuidv4(),
          role: 'assistant',
          content: text,
          timestamp: Date.now(),
          conversation_id: conversationId,
          chat_type: 'ai-search',
          metadata: searchResults ? JSON.stringify({ 
            searchQuery,
            searchResults: searchResults 
          }) : undefined
        };
        stmts.insertMessage.run(
          assistantMessage.id,
          assistantMessage.role,
          assistantMessage.content,
          assistantMessage.timestamp,
          assistantMessage.conversation_id,
          assistantMessage.chat_type,
          assistantMessage.metadata
        );
      } catch (error) {
        console.error('Failed to store assistant message:', error);
      }
    });

    return response;
  } catch (error) {
    console.error(`Failed to stream with model ${modelId}:`, error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    return new Response(
      JSON.stringify({
        error: `Failed to initialize ${modelId}: ${errorMessage}. Please check your API keys and try again.`
      }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}



================================================
File: app/api/tavily-search/route.ts
================================================
// app/api/tavily-search/route.ts
import { NextRequest } from "next/server";
import { searchTavily, TavilySearchParams } from "@/tools/tavily-search";

export async function POST(request: NextRequest) {
  try {
    const params: TavilySearchParams = await request.json();
    
    if (!params.query) {
      return new Response(
        JSON.stringify({ error: "Query parameter is required" }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }
    
    // If modelId is not provided, use a default identifier for direct API calls
    if (!params.modelId) {
      params.modelId = "direct-api-call";
    }
    
    const results = await searchTavily(params);
    
    return new Response(
      JSON.stringify(results),
      { status: 200, headers: { 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error("Tavily API route error:", error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    
    return new Response(
      JSON.stringify({ error: `Tavily search failed: ${errorMessage}` }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}



================================================
File: app/chat-history/page.tsx
================================================
"use client";

import Link from "next/link";
import { useState, useEffect } from "react";
import type { ChatType } from "@/lib/db";

interface Conversation {
  conversation_id: string;
  start_time: number;
  message_count: number;
  chat_type: ChatType;
  metadata?: string;
}

function formatDateTime(timestamp: number) {
  const date = new Date(timestamp);
  const day = date.toLocaleDateString('en-US', { weekday: 'short' }).toLowerCase();
  const hours = date.getHours().toString().padStart(2, '0');
  const minutes = date.getMinutes().toString().padStart(2, '0');
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  const dayOfMonth = date.getDate().toString().padStart(2, '0');
  const year = date.getFullYear();

  return `${day}-${hours}${minutes}-${month}${dayOfMonth}${year}`;
}

export default function ChatHistoryPage() {
  const [selectedType, setSelectedType] = useState<ChatType | 'all'>('all');
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchConversations = async () => {
      try {
        setIsLoading(true);
        setError(null);
        const response = await fetch(`/api/chat/history?type=${selectedType}`);
        if (!response.ok) {
          throw new Error('Failed to fetch conversations');
        }
        const data = await response.json();
        setConversations(data.conversations);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load chat history');
        console.error('Error fetching conversations:', err);
      } finally {
        setIsLoading(false);
      }
    };

    fetchConversations();
  }, [selectedType]);

  const renderMetadata = (conversation: Conversation) => {
    if (!conversation.metadata) return null;
    const metadata = JSON.parse(conversation.metadata);
    
    switch (conversation.chat_type) {
      case 'ai-search':
        return metadata.searchQuery ? (
          <p className="text-sm text-gray-500">
            Search: {metadata.searchQuery}
          </p>
        ) : null;
      case 'ai-agent':
        return metadata.primaryModel ? (
          <p className="text-sm text-gray-500">
            Models: {metadata.primaryModel.label} + {metadata.secondaryModel.label}
          </p>
        ) : null;
      default:
        return null;
    }
  };

  return (
    <div className="flex flex-col w-full max-w-4xl mx-auto p-4">
      {error && (
        <div className="bg-red-50 border border-red-200 text-red-700 p-4 rounded-md mb-4">
          {error}
        </div>
      )}
      
      {isLoading ? (
        <div className="flex justify-center items-center py-12">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900"></div>
        </div>
      ) : (
        <>
          <div className="flex justify-between items-center mb-6">
            <h1 className="text-2xl font-bold">Chat History</h1>
            <select
              value={selectedType}
              onChange={(e) => setSelectedType(e.target.value as ChatType | 'all')}
              className="px-3 py-2 border rounded-md bg-background"
            >
              <option value="all">All Chats</option>
              <option value="chat">Regular Chat</option>
              <option value="ai-search">AI Search</option>
              <option value="ai-agent">AI Agent</option>
            </select>
          </div>
          <div className="space-y-4">
            {conversations.map((conversation) => {
              const dateTime = formatDateTime(conversation.start_time);
              return (
                <div
                  key={conversation.conversation_id}
                  className="border border-gray-200 rounded-lg p-4 hover:bg-gray-50 transition-colors"
                >
                  <Link
                    href={`${conversation.chat_type === 'chat' 
                      ? '/' 
                      : conversation.chat_type === 'ai-search'
                      ? '/tavily-ai-search'
                      : '/ai-agents'}?conversation=${conversation.conversation_id}`}
                    className="flex justify-between items-center"
                  >
                    <div>
                      <h2 className="text-lg font-medium">{dateTime}</h2>
                      <div>
                        <p className="text-sm text-gray-500">
                          {conversation.message_count} messages
                        </p>
                        {renderMetadata(conversation)}
                      </div>
                    </div>
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="24"
                      height="24"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      className="text-gray-400"
                    >
                      <polyline points="9 18 15 12 9 6" />
                    </svg>
                  </Link>
                </div>
              );
            })}
          </div>
        </>
      )}
    </div>
  );
}



================================================
File: app/tavily-ai-search/page.tsx
================================================
import { TavilyChat } from "@/components/tavily-chat";

export default function TavilySearchPage() {
  return (
    <div className="flex flex-col size-full items-center">
      <TavilyChat />
    </div>
  );
}



================================================
File: components/chat.tsx
================================================
"use client";

import cn from "classnames";
import { toast } from "sonner";
import { useChat } from "@ai-sdk/react";
import { useState, useRef, useEffect } from "react";
import { useSearchParams } from "next/navigation";
import { Messages } from "./messages";
import { models } from "@/lib/models";
import { Footnote } from "./footnote";
import { ArrowUpIcon, CheckedSquare, StopIcon, UncheckedSquare, PaperClipIcon, XIcon } from "./icons";
import { ModelSelector } from "./model-selector";
import { Input } from "./input";
import Image from "next/image";

export function Chat() {
  const [input, setInput] = useState<string>("");
  const [selectedModelId, setSelectedModelId] = useState<string>("claude-3.7-sonnet");
  const [isReasoningEnabled, setIsReasoningEnabled] = useState<boolean>(true);
  const [files, setFiles] = useState<FileList | null>(null);
  const [isLoadingHistory, setIsLoadingHistory] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Default values for the following features 
  const reasoningModeEnabled = true;
  const multimodalEnabled = true;

  const selectedModel = models.find((model) => model.id === selectedModelId);

  const searchParams = useSearchParams();
  const conversationId = searchParams.get('conversation') || undefined;

  const { messages, append, status, stop, setMessages } = useChat({
    id: conversationId || "primary",
    body: {
      selectedModelId,
      isReasoningEnabled: reasoningModeEnabled ? isReasoningEnabled : false,
      conversationId,
    },
    onError: () => {
      toast.error("An error occurred, please try again!");
    },
  });

  // Load conversation history without triggering LLM responses
  useEffect(() => {
    async function loadHistory() {
      if (conversationId && messages.length === 0 && !isLoadingHistory) {
        setIsLoadingHistory(true);
        try {
          const response = await fetch(`/api/chat/history/${conversationId}`);
          const data = await response.json();
          
          if (data.messages) {
            // Transform messages to match expected format with parts array
            const formattedMessages = data.messages.map((msg: any) => {
              const messageParts = [];
              
              // Add reasoning block if it exists in metadata
              if (msg.metadata) {
                try {
                  const metadata = JSON.parse(msg.metadata);
                  if (metadata.reasoning) {
                    messageParts.push({
                      type: "reasoning",
                      reasoning: metadata.reasoning,
                      details: [{ type: "text", text: metadata.reasoning }]
                    });
                  }
                } catch (e) {
                  console.error('Error parsing message metadata:', e);
                }
              }
              
              // Try to parse and format JSON content if present
              const content = msg.content;
              const isJson = content.trim().startsWith('{') || content.trim().startsWith('[');
              
              if (isJson) {
                try {
                  const formattedJson = JSON.stringify(JSON.parse(content), null, 2);
                  messageParts.push({
                    type: "text",
                    text: "```json\n" + formattedJson + "\n```"
                  });
                } catch (e) {
                  messageParts.push({
                    type: "text",
                    text: content
                  });
                }
              } else {
                messageParts.push({
                  type: "text",
                  text: content
                });
              }

              return {
                id: msg.id,
                role: msg.role,
                content: msg.content,
                parts: messageParts,
                ...(msg.metadata && {
                  experimental_attachments: (() => {
                    try {
                      const metadata = JSON.parse(msg.metadata);
                      return metadata.attachments || [];
                    } catch (e) {
                      return [];
                    }
                  })()
                })
              };
            });
            
            setMessages(formattedMessages);
          }
        } catch (err) {
          console.error('Failed to load chat history:', err);
          toast.error("Failed to load chat history");
        } finally {
          setIsLoadingHistory(false);
        }
      }
    }
    
    loadHistory();
  }, [conversationId, messages.length, setMessages, isLoadingHistory]);

  const isGeneratingResponse = ["streaming", "submitted"].includes(status);

  const handleSendMessage = () => {
    if (input === "" && (!files || files.length === 0)) {
      return;
    }

    if (isGeneratingResponse) {
      stop();
    } else {
      append({
        role: "user",
        content: input,
      }, {
        experimental_attachments: files || undefined,
      });
    }

    setInput("");
    setFiles(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleRemoveFile = () => {
    setFiles(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  // Create file preview URL
  const filePreviewUrl = files && files.length > 0 && files[0].type.startsWith('image/') 
    ? URL.createObjectURL(files[0]) 
    : null;

  return (
    <div
      className={cn(
        "px-4 md:px-0 pb-4 pt-8 flex flex-col h-dvh items-center w-full",
        {
          "justify-between": messages.length > 0,
          "justify-center gap-4": messages.length === 0,
        },
      )}
    >
      {isLoadingHistory ? (
        <div className="flex justify-center items-center py-12">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900"></div>
        </div>
      ) : messages.length > 0 ? (
        <Messages messages={messages} status={status} />
      ) : (
        <div className="flex flex-col gap-0.5 sm:text-2xl text-xl md:w-1/2 w-full">
          <div className="flex flex-row gap-2 items-center">
            <div>Trainnect AI.</div>
          </div>
          <div className="dark:text-zinc-500 text-zinc-400">
            Search Less, Learn More
          </div>
        </div>
      )}

      <div className="flex flex-col gap-4 md:w-1/2 w-full">
        <div className="w-full relative p-3 dark:bg-zinc-800 rounded-2xl flex flex-col gap-1 bg-zinc-100">
          {multimodalEnabled && files && files.length > 0 && (
            <div className="mb-2 flex items-center" data-testid="file-preview">
              {filePreviewUrl ? (
                <div className="relative w-16 h-16 mr-2">
                  <Image 
                    src={filePreviewUrl} 
                    alt={files[0].name}
                    fill
                    style={{ objectFit: 'cover' }}
                    className="rounded-md"
                  />
                </div>
              ) : (
                <div className="flex items-center justify-center w-16 h-16 bg-zinc-200 dark:bg-zinc-700 rounded-md mr-2">
                  <span className="text-xs">{files[0].name.split('.').pop()?.toUpperCase()}</span>
                </div>
              )}
              <div className="flex-1">
                <div className="text-sm truncate">{files[0].name}</div>
                <div className="text-xs text-zinc-500">{(files[0].size / 1024).toFixed(1)} KB</div>
              </div>
              <button 
                onClick={handleRemoveFile}
                className="p-1 rounded-full hover:bg-zinc-200 dark:hover:bg-zinc-700"
              >
                <XIcon className="h-4 w-4" />
              </button>
            </div>
          )}
          
          <Input
            input={input}
            setInput={setInput}
            selectedModelId={selectedModelId}
            isGeneratingResponse={isGeneratingResponse}
            isReasoningEnabled={reasoningModeEnabled ? isReasoningEnabled : false}
            append={append}
          />

          {reasoningModeEnabled && (
            <div className="absolute bottom-2.5 left-2.5">
              <div
                className={cn(
                  "relative w-fit text-sm p-1.5 rounded-lg flex flex-row items-center gap-2 dark:hover:bg-zinc-600 hover:bg-zinc-200 cursor-pointer",
                  {
                    "dark:bg-zinc-600 bg-zinc-200": isReasoningEnabled,
                  },
                )}
                onClick={() => {
                  setIsReasoningEnabled(!isReasoningEnabled);
                }}
              >
                {isReasoningEnabled ? <CheckedSquare /> : <UncheckedSquare />}
                <div>Reasoning</div>
              </div>
            </div>
          )}

          <div className="absolute bottom-2.5 right-2.5 flex flex-row gap-2">
            {multimodalEnabled && (
              <button
                className="size-8 flex flex-row justify-center items-center dark:bg-zinc-700 bg-zinc-300 dark:text-zinc-300 text-zinc-700 p-1.5 rounded-full hover:bg-zinc-400 dark:hover:bg-zinc-600 hover:scale-105 active:scale-95 transition-all"
                onClick={() => fileInputRef.current?.click()}
              >
                <PaperClipIcon />
                <input
                  type="file"
                  className="hidden"
                  onChange={(e) => setFiles(e.target.files)}
                  ref={fileInputRef}
                  accept="image/*, application/pdf"
                  data-testid="file-upload"
                />
              </button>
            )}
            
            <ModelSelector 
              selectedModelId={selectedModelId}
              setSelectedModelId={setSelectedModelId}
            />

            <button
              className={cn(
                "size-8 flex flex-row justify-center items-center dark:bg-zinc-100 bg-zinc-900 dark:text-zinc-900 text-zinc-100 p-1.5 rounded-full hover:bg-zinc-800 dark:hover:bg-zinc-300 hover:scale-105 active:scale-95 transition-all",
                {
                  "dark:bg-zinc-200 dark:text-zinc-500":
                    isGeneratingResponse || (input === "" && (!files || files.length === 0)),
                },
              )}
              onClick={handleSendMessage}
              aria-label="send"
            >
              {isGeneratingResponse ? <StopIcon /> : <ArrowUpIcon />}
            </button>
          </div>
        </div>

        <Footnote />
      </div>
    </div>
  );
}



================================================
File: components/deploy-button.tsx
================================================
import Link from "next/link";
export const DeployButton = () => (
  <Link
    href={`https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fvercel-labs%2Fai-sdk-preview-reasoning%2Ftree%2Fmain&env=ANTHROPIC_API_KEY&envDescription=Anthropic%20API%20key&envLink=https%3A%2F%2Fconsole.anthropic.com%2F`}
    target="_blank"
    rel="noopener noreferrer"
    className="inline-flex items-center gap-2 ml-2 bg-black text-white text-sm px-3 py-1.5 rounded-md hover:bg-zinc-900 dark:bg-white dark:text-black dark:hover:bg-zinc-100"
  >
    <svg
      data-testid="geist-icon"
      height={14}
      strokeLinejoin="round"
      viewBox="0 0 16 16"
      width={14}
      style={{ color: "currentcolor" }}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M8 1L16 15H0L8 1Z"
        fill="currentColor"
      />
    </svg>
    Deploy
  </Link>
);



================================================
File: components/footnote.tsx
================================================
import Link from 'next/link';

export function Footnote() {
  return (
    <div className="text-xs text-zinc-400 leading-5 hidden sm:block">
      This app is built using{' '}
      <Link
        className="underline underline-offset-2"
        href="https://nextjs.org/"
        target="_blank"
      >
        Next.js
      </Link>{' '}
      15{' '}
      <Link
        className="underline underline-offset-2"
        href="https://sdk.vercel.ai/"
        target="_blank"
      >
        React 19
      </Link>
      . Trainnect, Search Less, Learn More{' '}
      <Link
        className="underline underline-offset-2"
        href="https://trainnect.com"
        target="_blank"
      >
        documentation
      </Link>
      .
    </div>
  );
}


================================================
File: components/icons.tsx
================================================
export const ArrowUpIcon = ({ size = 16 }: { size?: number }) => (
  <svg
    height={size}
    strokeLinejoin="round"
    viewBox="0 0 16 16"
    width={size}
    style={{ color: "currentcolor" }}
  >
    <path
      fillRule="evenodd"
      clipRule="evenodd"
      d="M8.70711 1.39644C8.31659 1.00592 7.68342 1.00592 7.2929 1.39644L2.21968 6.46966L1.68935 6.99999L2.75001 8.06065L3.28034 7.53032L7.25001 3.56065V14.25V15H8.75001V14.25V3.56065L12.7197 7.53032L13.25 8.06065L14.3107 6.99999L13.7803 6.46966L8.70711 1.39644Z"
      fill="currentColor"
    ></path>
  </svg>
);

export const ChevronDownIcon = ({ size = 16 }: { size?: number }) => (
  <svg
    height={size}
    strokeLinejoin="round"
    viewBox="0 0 16 16"
    width={size}
    style={{ color: "currentcolor" }}
  >
    <path
      fillRule="evenodd"
      clipRule="evenodd"
      d="M12.0607 6.74999L11.5303 7.28032L8.7071 10.1035C8.31657 10.4941 7.68341 10.4941 7.29288 10.1035L4.46966 7.28032L3.93933 6.74999L4.99999 5.68933L5.53032 6.21966L7.99999 8.68933L10.4697 6.21966L11 5.68933L12.0607 6.74999Z"
      fill="currentColor"
    />
  </svg>
);

export const ChevronUpIcon = ({ size = 16 }: { size?: number }) => (
  <svg
    height={size}
    strokeLinejoin="round"
    viewBox="0 0 16 16"
    width={size}
    style={{ color: "currentcolor" }}
    className="rotate-0"
  >
    <path
      fillRule="evenodd"
      clipRule="evenodd"
      d="M6.74999 3.93933L7.28032 4.46966L10.1035 7.29288C10.4941 7.68341 10.4941 8.31657 10.1035 8.7071L7.28032 11.5303L6.74999 12.0607L5.68933 11L6.21966 10.4697L8.68933 7.99999L6.21966 5.53032L5.68933 4.99999L6.74999 3.93933Z"
      fill="currentColor"
    ></path>
  </svg>
);

export const SpinnerIcon = ({ size = 16 }: { size?: number }) => (
  <svg
    height={size}
    strokeLinejoin="round"
    viewBox="0 0 16 16"
    width={size}
    style={{ color: "currentcolor" }}
  >
    <g clipPath="url(#clip0_2393_1490)">
      <path d="M8 0V4" stroke="currentColor" strokeWidth="1.5" />
      <path
        opacity="0.5"
        d="M8 16V12"
        stroke="currentColor"
        strokeWidth="1.5"
      />
      <path
        opacity="0.9"
        d="M3.29773 1.52783L5.64887 4.7639"
        stroke="currentColor"
        strokeWidth="1.5"
      />
      <path
        opacity="0.1"
        d="M12.7023 1.52783L10.3511 4.7639"
        stroke="currentColor"
        strokeWidth="1.5"
      />
      <path
        opacity="0.4"
        d="M12.7023 14.472L10.3511 11.236"
        stroke="currentColor"
        strokeWidth="1.5"
      />
      <path
        opacity="0.6"
        d="M3.29773 14.472L5.64887 11.236"
        stroke="currentColor"
        strokeWidth="1.5"
      />
      <path
        opacity="0.2"
        d="M15.6085 5.52783L11.8043 6.7639"
        stroke="currentColor"
        strokeWidth="1.5"
      />
      <path
        opacity="0.7"
        d="M0.391602 10.472L4.19583 9.23598"
        stroke="currentColor"
        strokeWidth="1.5"
      />
      <path
        opacity="0.3"
        d="M15.6085 10.4722L11.8043 9.2361"
        stroke="currentColor"
        strokeWidth="1.5"
      />
      <path
        opacity="0.8"
        d="M0.391602 5.52783L4.19583 6.7639"
        stroke="currentColor"
        strokeWidth="1.5"
      />
    </g>
    <defs>
      <clipPath id="clip0_2393_1490">
        <rect width="16" height="16" fill="white" />
      </clipPath>
    </defs>
  </svg>
);

export const VercelIcon = ({ size = 17 }) => {
  return (
    <svg
      height={size}
      strokeLinejoin="round"
      viewBox="0 0 16 16"
      width={size}
      style={{ color: "currentcolor" }}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M8 1L16 15H0L8 1Z"
        fill="currentColor"
      />
    </svg>
  );
};

export const StopIcon = ({ size = 16 }: { size?: number }) => {
  return (
    <svg
      height={size}
      viewBox="0 0 16 16"
      width={size}
      style={{ color: "currentcolor" }}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M3 3H13V13H3V3Z"
        fill="currentColor"
      />
    </svg>
  );
};

export const CheckedSquare = ({ size = 16 }: { size?: number }) => {
  return (
    <svg
      height={size}
      strokeLinejoin="round"
      viewBox="0 0 16 16"
      width={size}
      style={{ color: "currentcolor" }}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M15 16H1C0.447715 16 0 15.5523 0 15V1C0 0.447715 0.447716 0 1 0L15 8.17435e-06C15.5523 8.47532e-06 16 0.447724 16 1.00001V15C16 15.5523 15.5523 16 15 16ZM11.7803 6.28033L12.3107 5.75L11.25 4.68934L10.7197 5.21967L6.5 9.43935L5.28033 8.21967L4.75001 7.68934L3.68934 8.74999L4.21967 9.28033L5.96967 11.0303C6.11032 11.171 6.30109 11.25 6.5 11.25C6.69891 11.25 6.88968 11.171 7.03033 11.0303L11.7803 6.28033Z"
        fill="currentColor"
      ></path>
    </svg>
  );
};

export const UncheckedSquare = ({ size = 16 }: { size?: number }) => {
  return (
    <svg
      height={size}
      strokeLinejoin="round"
      viewBox="0 0 16 16"
      width={size}
      style={{ color: "currentcolor" }}
    >
      <rect
        x="1"
        y="1"
        width="14"
        height="14"
        stroke="currentColor"
        strokeWidth="1.5"
        fill="none"
      />
    </svg>
  );
};

export const PaperClipIcon = ({ size = 16, className = "" }: { size?: number, className?: string }) => {
  return (
    <svg
      height={size}
      width={size}
      viewBox="0 0 16 16"
      className={className}
      style={{ color: "currentcolor" }}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M8 1.5a.5.5 0 01.5.5v4.793l1.146-1.147a.5.5 0 01.708.708l-2 2a.5.5 0 01-.708 0l-2-2a.5.5 0 11.708-.708L7.5 6.793V2a.5.5 0 01.5-.5zM4 9.5a.5.5 0 00-1 0v2A2.5 2.5 0 005.5 14h5a2.5 2.5 0 002.5-2.5v-2a.5.5 0 00-1 0v2a1.5 1.5 0 01-1.5 1.5h-5A1.5 1.5 0 014 11.5v-2z"
        fill="currentColor"
      />
    </svg>
  );
};

export const XIcon = ({ size = 16, className = "" }: { size?: number, className?: string }) => {
  return (
    <svg
      height={size}
      width={size}
      viewBox="0 0 16 16"
      className={className}
      style={{ color: "currentcolor" }}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M12.0607 3.93934L8 8.00001L3.93934 3.93934L2.87868 5.00001L6.93934 9.06067L2.87868 13.1213L3.93934 14.182L8 10.1213L12.0607 14.182L13.1213 13.1213L9.06066 9.06067L13.1213 5.00001L12.0607 3.93934Z"
        fill="currentColor"
      />
    </svg>
  );
};

export function SearchIcon({ size = 16, className = "" }: { size?: number, className?: string }) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      className={className}
    >
      <circle cx="11" cy="11" r="8" />
      <path d="m21 21-4.3-4.3" />
    </svg>
  );
}



================================================
File: components/input.tsx
================================================
"use client";

import { toast } from "sonner";
import { Message, CreateMessage, ChatRequestOptions } from "ai";

interface InputProps {
  input: string;
  setInput: (value: string) => void;
  selectedModelId: string;
  isGeneratingResponse: boolean;
  isReasoningEnabled: boolean;
  append?: (message: Message | CreateMessage, chatRequestOptions?: ChatRequestOptions) => Promise<string | null | undefined>;
}

export function Input({
  input,
  setInput,
  selectedModelId,
  isGeneratingResponse,
  isReasoningEnabled,
  append,
}: InputProps) {

  return (
    <textarea
      className="mb-12 resize-none w-full min-h-12 outline-none bg-transparent placeholder:text-zinc-400"
      placeholder="Send a message"
      value={input}
      autoFocus
      onChange={(event) => {
        setInput(event.currentTarget.value);
      }}
      onKeyDown={(event) => {
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();

          if (input === "") {
            return;
          }

          if (isGeneratingResponse) {
            toast.error("Please wait for the model to finish its response!");

            return;
          }

          if (append) {
            append({
              role: "user",
              content: input,
            });
          }

          setInput("");
        }
      }}
    />
  );
}



================================================
File: components/markdown-components.tsx
================================================
import { Components } from "react-markdown";
import Link from "next/link";

export const markdownComponents: Partial<Components> = {
  p: ({ children }) => <p className="leading-6">{children}</p>,
  pre: ({ children, className }) => (
    <pre className="bg-gray-100 dark:bg-zinc-800 rounded-lg p-4 my-2 overflow-x-auto text-sm font-mono">
      {children}
    </pre>
  ),
  code: ({ children }) => (
    <code className="bg-gray-100 dark:bg-zinc-800 rounded-md px-1.5 py-0.5 text-sm font-mono">
      {children}
    </code>
  ),
  ol: ({ children, ...props }) => {
    return (
      <ol className="list-decimal list-outside ml-4" {...props}>
        {children}
      </ol>
    );
  },
  li: ({ children, ...props }) => {
    return (
      <li className="py-1" {...props}>
        {children}
      </li>
    );
  },
  ul: ({ children, ...props }) => {
    return (
      <ul className="list-disc list-outside ml-4" {...props}>
        {children}
      </ul>
    );
  },
  strong: ({ children, ...props }) => {
    return (
      <span className="font-semibold" {...props}>
        {children}
      </span>
    );
  },
  a: ({ children, ...props }) => {
    return (
      // @ts-expect-error - Link component expects href prop from markdown-parsed anchor tags
      <Link
        className="text-blue-500 hover:underline"
        target="_blank"
        rel="noreferrer"
        {...props}
      >
        {children}
      </Link>
    );
  },
  h1: ({ children, ...props }) => {
    return (
      <h1 className="text-3xl font-semibold mt-6 mb-2" {...props}>
        {children}
      </h1>
    );
  },
  h2: ({ children, ...props }) => {
    return (
      <h2 className="text-2xl font-semibold mt-6 mb-2" {...props}>
        {children}
      </h2>
    );
  },
  h3: ({ children, ...props }) => {
    return (
      <h3 className="text-xl font-semibold mt-6 mb-2" {...props}>
        {children}
      </h3>
    );
  },
  h4: ({ children, ...props }) => {
    return (
      <h4 className="text-lg font-semibold mt-6 mb-2" {...props}>
        {children}
      </h4>
    );
  },
  h5: ({ children, ...props }) => {
    return (
      <h5 className="text-base font-semibold mt-6 mb-2" {...props}>
        {children}
      </h5>
    );
  },
  h6: ({ children, ...props }) => {
    return (
      <h6 className="text-sm font-semibold mt-6 mb-2" {...props}>
        {children}
      </h6>
    );
  },
};



================================================
File: components/messages.tsx
================================================
"use client";

import cn from "classnames";
import Markdown from "react-markdown";
import { markdownComponents } from "./markdown-components";
import { AnimatePresence, motion } from "framer-motion";
import { useEffect, useMemo, useRef, useState } from "react";
import { ChevronDownIcon, ChevronUpIcon, SpinnerIcon } from "./icons";
import { UIMessage } from "ai";
import { UseChatHelpers } from "@ai-sdk/react";
import Image from "next/image";

interface ReasoningPart {
  type: "reasoning";
  reasoning: string;
  details: Array<{ type: "text"; text: string }>;
}

interface ReasoningMessagePartProps {
  part: ReasoningPart;
  isReasoning: boolean;
}

export function ReasoningMessagePart({
  part,
  isReasoning,
}: ReasoningMessagePartProps) {
  const [isExpanded, setIsExpanded] = useState(true);

  const variants = {
    collapsed: {
      height: 0,
      opacity: 0,
      marginTop: 0,
      marginBottom: 0,
    },
    expanded: {
      height: "auto",
      opacity: 1,
      marginTop: "1rem",
      marginBottom: 0,
    },
  };

  return (
    <div className="flex flex-col">
      {isReasoning ? (
        <div className="flex flex-row gap-2 items-center">
          <div className="font-medium text-sm">Reasoning</div>
          <div className="animate-spin">
            <SpinnerIcon />
          </div>
        </div>
      ) : (
        <div className="flex flex-row gap-2 items-center">
          <div className="font-medium text-sm">Reasoned for a few seconds</div>
          <button
            className={cn(
              "cursor-pointer rounded-full dark:hover:bg-zinc-800 hover:bg-zinc-200",
              {
                "dark:bg-zinc-800 bg-zinc-200": isExpanded,
              },
            )}
            onClick={() => {
              setIsExpanded(!isExpanded);
            }}
          >
            {isExpanded ? <ChevronDownIcon /> : <ChevronUpIcon />}
          </button>
        </div>
      )}

      <AnimatePresence initial={false}>
        {isExpanded && (
          <motion.div
            key="reasoning"
            className="text-sm dark:text-zinc-400 text-zinc-600 flex flex-col gap-4 border-l pl-3 dark:border-zinc-800"
            initial="collapsed"
            animate="expanded"
            exit="collapsed"
            variants={variants}
            transition={{ duration: 0.2, ease: "easeInOut" }}
          >
            {part.details.map((detail, detailIndex) =>
              detail.type === "text" ? (
                <Markdown key={detailIndex} components={markdownComponents}>
                  {detail.text}
                </Markdown>
              ) : (
                "<redacted>"
              ),
            )}

            {/* <Markdown components={markdownComponents}>{reasoning}</Markdown> */}
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

interface TextMessagePartProps {
  text: string;
}

export function TextMessagePart({ text }: TextMessagePartProps) {
  return (
    <div className="flex flex-col gap-4">
      <Markdown components={markdownComponents}>{text}</Markdown>
    </div>
  );
}

interface AttachmentProps {
  attachment: {
    name?: string;
    url: string;
    contentType: string;
  };
  index: number;
  messageId: string;
}

export function Attachment({ attachment, index, messageId }: AttachmentProps) {
  if (attachment.contentType.startsWith('image/')) {
    return (
      <div className="mt-2 relative w-full max-w-md h-auto">
        <Image
          key={`${messageId}-${index}`}
          src={attachment.url}
          alt={attachment.name || `attachment-${index}`}
          width={500}
          height={300}
          className="rounded-md object-contain"
          style={{ maxHeight: '300px' }}
        />
      </div>
    );
  } else if (attachment.contentType.startsWith('application/pdf')) {
    return (
      <div className="mt-2 w-full max-w-md">
        <div className="bg-zinc-100 dark:bg-zinc-800 p-2 rounded-md flex items-center gap-2 mb-2">
          <div className="text-sm font-medium">PDF Document: {attachment.name || `Document-${index}`}</div>
        </div>
        <iframe
          key={`${messageId}-${index}`}
          src={attachment.url}
          title={attachment.name || `attachment-${index}`}
          className="w-full rounded-md border border-zinc-300 dark:border-zinc-700"
          height={400}
        />
      </div>
    );
  }
  
  return null;
}

interface MessagesProps {
  messages: Array<UIMessage>;
  status: UseChatHelpers["status"];
}

export function Messages({ messages, status }: MessagesProps) {
  const messagesRef = useRef<HTMLDivElement>(null);
  const messagesLength = useMemo(() => messages.length, [messages]);

  useEffect(() => {
    if (messagesRef.current) {
      messagesRef.current.scrollTop = messagesRef.current.scrollHeight;
    }
  }, [messagesLength]);

  return (
    <div
      className="flex flex-col gap-8 overflow-y-scroll items-center w-full"
      ref={messagesRef}
    >
      {messages.map((message) => (
        <div
          key={message.id}
          className={cn(
            "flex flex-col gap-4 last-of-type:mb-12 first-of-type:mt-16 md:w-1/2 w-full",
          )}
        >
          <div
            className={cn("flex flex-col gap-4", {
              "dark:bg-zinc-800 bg-zinc-200 p-2 rounded-xl w-fit ml-auto":
                message.role === "user",
              "": message.role === "assistant",
            })}
          >
            {/* Display message text content */}
            {message.parts.map((part, partIndex) => {
              if (part.type === "text") {
                return (
                  <TextMessagePart
                    key={`${message.id}-${partIndex}`}
                    text={part.text}
                  />
                );
              }

              if (part.type === "reasoning") {
                return (
                  <ReasoningMessagePart
                    key={`${message.id}-${partIndex}`}
                    // @ts-expect-error export ReasoningUIPart
                    part={part}
                    isReasoning={
                      status === "streaming" &&
                      partIndex === message.parts.length - 1
                    }
                  />
                );
              }
            })}
            
            {/* Display attachments if present */}
            {message.experimental_attachments && message.experimental_attachments.length > 0 && (
              <div className="flex flex-col gap-2">
                {message.experimental_attachments.map((attachment, attachmentIndex) => {
                  // Ensure attachment has required properties before rendering
                  if (attachment && attachment.url && attachment.contentType) {
                    return (
                      <Attachment 
                        key={`${message.id}-attachment-${attachmentIndex}`}
                        attachment={{
                          name: attachment.name,
                          url: attachment.url,
                          contentType: attachment.contentType
                        }}
                        index={attachmentIndex}
                        messageId={message.id}
                      />
                    );
                  }
                  return null;
                })}
              </div>
            )}
          </div>
        </div>
      ))}

      {status === "submitted" && (
        <div className="text-zinc-500 mb-12 md:w-1/2 w-full">Hmm...</div>
      )}
    </div>
  );
}



================================================
File: components/model-selector.tsx
================================================
"use client";

import { useState, useRef, useEffect } from "react";
import cn from "classnames";
import { models } from "@/lib/models";
import { ChevronDownIcon } from "./icons";

interface ModelSelectorProps {
  selectedModelId: string;
  setSelectedModelId: (modelId: string) => void;
}

export function ModelSelector({
  selectedModelId,
  setSelectedModelId,
}: ModelSelectorProps) {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  
  const selectedModel = models.find((model) => model.id === selectedModelId);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);

  return (
    <div className="relative" ref={dropdownRef}>
      <button
        className="relative w-fit text-sm p-1.5 rounded-lg flex flex-row items-center gap-0.5 dark:hover:bg-zinc-700 hover:bg-zinc-200 cursor-pointer"
        onClick={() => setIsOpen(!isOpen)}
        aria-haspopup="listbox"
        aria-expanded={isOpen}
      >
        <div>
          {selectedModel ? selectedModel.name : "Models Unavailable!"}
        </div>
        <div className="text-zinc-500">
          <ChevronDownIcon />
        </div>
      </button>

      {isOpen && (
        <div className="absolute bottom-full mb-2 right-0 w-64 max-h-80 overflow-y-auto bg-white dark:bg-zinc-800 rounded-lg shadow-lg z-10">
          <ul
            className="py-1"
            role="listbox"
            aria-labelledby="model-selector"
          >
            {models.map((model) => (
              <li
                key={model.id}
                className={cn(
                  "px-4 py-2 cursor-pointer hover:bg-zinc-100 dark:hover:bg-zinc-700",
                  {
                    "bg-zinc-100 dark:bg-zinc-700": model.id === selectedModelId,
                  }
                )}
                role="option"
                aria-selected={model.id === selectedModelId}
                onClick={() => {
                  setSelectedModelId(model.id);
                  setIsOpen(false);
                }}
              >
                <div className="font-medium">{model.name}</div>
                <div className="text-xs text-zinc-500 dark:text-zinc-400 line-clamp-2">
                  {model.description}
                </div>
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}



================================================
File: components/navigation.tsx
================================================
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { SearchIcon } from "./icons";
import cn from "classnames";

export function Navigation() {
  const pathname = usePathname();
  
  return (
    <div className="fixed top-4 right-4 z-10 flex gap-2">
      <Link
        href="/"
        className={cn(
          "p-2 rounded-full hover:bg-zinc-200 dark:hover:bg-zinc-700 transition-colors",
          {
            "bg-zinc-200 dark:bg-zinc-700": pathname === "/",
          }
        )}
        aria-label="Home"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" />
          <polyline points="9 22 9 12 15 12 15 22" />
        </svg>
      </Link>
      
      <Link
        href="/tavily-ai-search"
        className={cn(
          "p-2 rounded-full hover:bg-zinc-200 dark:hover:bg-zinc-700 transition-colors",
          {
            "bg-zinc-200 dark:bg-zinc-700": pathname === "/tavily-ai-search",
          }
        )}
        aria-label="Tavily AI Search"
      >
        <SearchIcon size={24} />
      </Link>
    </div>
  );
}



================================================
File: components/sidebar.tsx
================================================
"use client";

import React, { useState } from "react";
import { cn } from "@/lib/utils";
import Link from "next/link";
import { motion } from "framer-motion";
import { 
  LayoutDashboard, 
  Search,
  MessageSquare,
  Menu,
  X,
  Settings,
  Moon,
  Sun,
  History
} from "lucide-react";
import { useTheme } from "next-themes";

interface SidebarLinkProps {
  label: string;
  href: string;
  icon: React.ReactNode;
}

interface SidebarProps {
  open?: boolean;
  setOpen?: React.Dispatch<React.SetStateAction<boolean>>;
  children: React.ReactNode;
}

interface SidebarBodyProps extends React.ComponentProps<typeof motion.div> {
  className?: string;
  children: React.ReactNode;
}

interface SidebarLinkComponentProps {
  link: SidebarLinkProps;
  className?: string;
}

const SidebarContext = React.createContext<{
  open: boolean;
  setOpen: React.Dispatch<React.SetStateAction<boolean>>;
  animate: boolean;
} | null>(null);

export const useSidebar = () => {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider");
  }
  return context;
};

export const SidebarProvider = ({
  children,
  open: openProp,
  setOpen: setOpenProp,
  animate = true,
}: {
  children: React.ReactNode;
  open?: boolean;
  setOpen?: React.Dispatch<React.SetStateAction<boolean>>;
  animate?: boolean;
}) => {
  const [openState, setOpenState] = useState(false);

  const open = openProp !== undefined ? openProp : openState;
  const setOpen = setOpenProp !== undefined ? setOpenProp : setOpenState;

  return (
    <SidebarContext.Provider value={{ open, setOpen, animate }}>
      {children}
    </SidebarContext.Provider>
  );
};

export const Sidebar = ({ children, open, setOpen }: SidebarProps) => {
  return (
    <SidebarProvider open={open} setOpen={setOpen}>
      {children}
    </SidebarProvider>
  );
};

const ThemeToggle = () => {
  const { theme, setTheme } = useTheme();
  const [mounted, setMounted] = React.useState(false);

  React.useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return (
      <button className="h-8 w-8 flex items-center justify-center rounded-md hover:bg-accent">
        <Sun size={16} />
      </button>
    );
  }
  
  return (
    <button
      onClick={() => setTheme(theme === "dark" ? "light" : "dark")}
      className="h-8 w-8 flex items-center justify-center rounded-md hover:bg-accent"
    >
      {theme === "dark" ? <Sun size={16} /> : <Moon size={16} />}
    </button>
  );
};

export const SidebarBody = ({ className, children, ...props }: SidebarBodyProps) => {
  const { open, setOpen, animate } = useSidebar();

  return (
    <>
      <motion.div
        {...props}
        animate={{
          width: open ? "240px" : "80px",
          transition: {
            duration: animate ? 0.2 : 0,
          },
        }}
        className={cn(
          "border-r border-border bg-background fixed h-screen flex flex-col p-3 gap-3",
          className
        )}
      >
        <div className="flex items-center justify-between h-12">
          <Logo />
          <div className="flex gap-1">
            <ThemeToggle />
            <button
              onClick={() => setOpen(!open)}
              className="h-8 w-8 flex items-center justify-center rounded-md hover:bg-accent"
            >
              {open ? <X size={16} /> : <Menu size={16} />}
            </button>
          </div>
        </div>
        {children}
      </motion.div>
      <div
        style={{
          width: open ? "240px" : "80px",
          transition: animate ? "width 0.2s" : "none",
        }}
      />
    </>
  );
};

export const SidebarLink = ({
  link,
  className,
}: SidebarLinkComponentProps) => {
  const { open } = useSidebar();

  return (
    <Link
      href={link.href}
      className={cn(
        "flex items-center gap-2 text-muted-foreground hover:text-foreground px-3 py-2 rounded-md hover:bg-accent transition-colors",
        className
      )}
    >
      {link.icon}
      <motion.span
        animate={{
          opacity: open ? 1 : 0,
          transition: { duration: 0.2 },
        }}
        className="text-sm whitespace-pre"
      >
        {link.label}
      </motion.span>
    </Link>
  );
};

export const Logo = () => {
  const { open } = useSidebar();
  
  return (
    <Link
      href="/"
      className="font-normal flex space-x-2 items-center text-sm text-foreground py-1 relative z-20"
    >
      <div className="h-5 w-6 bg-primary rounded-br-lg rounded-tr-sm rounded-tl-lg rounded-bl-sm flex-shrink-0" />
      {open && (
        <motion.span
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          className="font-medium text-foreground whitespace-pre"
        >
          Trainnect AI
        </motion.span>
      )}
    </Link>
  );
};

export const SidebarLinks = () => {
  return (
    <div className="flex flex-col gap-1">
      <SidebarLink
        link={{
          label: "Chat",
          href: "/",
          icon: <MessageSquare size={16} />,
        }}
      />
      <SidebarLink
        link={{
          label: "Chat History",
          href: "/chat-history",
          icon: <History size={16} />,
        }}
      />
      <SidebarLink
        link={{
          label: "AI Search",
          href: "/tavily-ai-search",
          icon: <Search size={16} />,
        }}
      />
      <SidebarLink
        link={{
          label: "AI Agents",
          href: "/ai-agents",
          icon: <LayoutDashboard size={16} />,
        }}
      />
      <SidebarLink
        link={{
          label: "Prompts",
          href: "/admin/prompts",
          icon: <Settings size={16} />,
        }}
      />
    </div>
  );
};



================================================
File: components/star-button.tsx
================================================
import Link from "next/link";
import * as React from "react";
import type { SVGProps } from "react";

const Github = (props: SVGProps<SVGSVGElement>) => (
  <svg
    viewBox="0 0 256 250"
    width="1em"
    height="1em"
    fill="currentColor"
    xmlns="http://www.w3.org/2000/svg"
    preserveAspectRatio="xMidYMid"
    {...props}
  >
    <path d="M128.001 0C57.317 0 0 57.307 0 128.001c0 56.554 36.676 104.535 87.535 121.46 6.397 1.185 8.746-2.777 8.746-6.158 0-3.052-.12-13.135-.174-23.83-35.61 7.742-43.124-15.103-43.124-15.103-5.823-14.795-14.213-18.73-14.213-18.73-11.613-7.944.876-7.78.876-7.78 12.853.902 19.621 13.19 19.621 13.19 11.417 19.568 29.945 13.911 37.249 10.64 1.149-8.272 4.466-13.92 8.127-17.116-28.431-3.236-58.318-14.212-58.318-63.258 0-13.975 5-25.394 13.188-34.358-1.329-3.224-5.71-16.242 1.24-33.874 0 0 10.749-3.44 35.21 13.121 10.21-2.836 21.16-4.258 32.038-4.307 10.878.049 21.837 1.47 32.066 4.307 24.431-16.56 35.165-13.12 35.165-13.12 6.967 17.63 2.584 30.65 1.255 33.873 8.207 8.964 13.173 20.383 13.173 34.358 0 49.163-29.944 59.988-58.447 63.157 4.591 3.972 8.682 11.762 8.682 23.704 0 17.126-.148 30.91-.148 35.126 0 3.407 2.304 7.398 8.792 6.14C219.37 232.5 256 184.537 256 128.002 256 57.307 198.691 0 128.001 0Zm-80.06 182.34c-.282.636-1.283.827-2.194.39-.929-.417-1.45-1.284-1.15-1.922.276-.655 1.279-.838 2.205-.399.93.418 1.46 1.293 1.139 1.931Zm6.296 5.618c-.61.566-1.804.303-2.614-.591-.837-.892-.994-2.086-.375-2.66.63-.566 1.787-.301 2.626.591.838.903 1 2.088.363 2.66Zm4.32 7.188c-.785.545-2.067.034-2.86-1.104-.784-1.138-.784-2.503.017-3.05.795-.547 2.058-.055 2.861 1.075.782 1.157.782 2.522-.019 3.08Zm7.304 8.325c-.701.774-2.196.566-3.29-.49-1.119-1.032-1.43-2.496-.726-3.27.71-.776 2.213-.558 3.315.49 1.11 1.03 1.45 2.505.701 3.27Zm9.442 2.81c-.31 1.003-1.75 1.459-3.199 1.033-1.448-.439-2.395-1.613-2.103-2.626.301-1.01 1.747-1.484 3.207-1.028 1.446.436 2.396 1.602 2.095 2.622Zm10.744 1.193c.036 1.055-1.193 1.93-2.715 1.95-1.53.034-2.769-.82-2.786-1.86 0-1.065 1.202-1.932 2.733-1.958 1.522-.03 2.768.818 2.768 1.868Zm10.555-.405c.182 1.03-.875 2.088-2.387 2.37-1.485.271-2.861-.365-3.05-1.386-.184-1.056.893-2.114 2.376-2.387 1.514-.263 2.868.356 3.061 1.403Z" />
  </svg>
);

export function StarButton() {
  return (
    <Link
      href="https://github.com/vercel-labs/ai-sdk-preview-reasoning"
      target="_blank"
      rel="noopener noreferrer"
      className="flex items-center gap-2 text-sm text-zinc-600 dark:text-zinc-300 hover:text-zinc-700 dark:hover:text-zinc-300"
    >
      <Github className="size-4" />
      <span className="hidden sm:inline">Star on GitHub</span>
    </Link>
  );
}



================================================
File: components/tavily-chat.tsx
================================================
"use client";

import cn from "classnames";
import { toast } from "sonner";
import { useChat } from "@ai-sdk/react";
import { useState, useRef } from "react";
import { Messages } from "./messages";
import { models } from "@/lib/models";
import { Footnote } from "./footnote";
import { ArrowUpIcon, CheckedSquare, StopIcon, UncheckedSquare, PaperClipIcon, XIcon, SearchIcon } from "./icons";
import { ModelSelector } from "./model-selector";
import { Input } from "./input";
import Image from "next/image";

export function TavilyChat() {
  const [input, setInput] = useState<string>("");
  const [searchQuery, setSearchQuery] = useState<string>("");
  const [selectedModelId, setSelectedModelId] = useState<string>("claude-3.7-sonnet");
  const [isReasoningEnabled, setIsReasoningEnabled] = useState<boolean>(true);
  const [files, setFiles] = useState<FileList | null>(null);
  const [isSearching, setIsSearching] = useState<boolean>(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Default values for the following features 
  const reasoningModeEnabled = true;
  const multimodalEnabled = true;

  const selectedModel = models.find((model) => model.id === selectedModelId);

  const { messages, append, status, stop } = useChat({
    id: "tavily-search",
    api: "/api/tavily-chat",
    body: {
      selectedModelId,
      isReasoningEnabled: reasoningModeEnabled ? isReasoningEnabled : false,
      searchQuery: isSearching ? input : undefined,
    },
    onError: () => {
      toast.error("An error occurred, please try again!");
    },
  });

  const isGeneratingResponse = ["streaming", "submitted"].includes(status);

  const handleSendMessage = () => {
    if (input === "" && (!files || files.length === 0)) {
      return;
    }

    if (isGeneratingResponse) {
      stop();
    } else {
      append({
        role: "user",
        content: input,
      }, {
        experimental_attachments: files || undefined,
      });
    }

    setInput("");
    setFiles(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleRemoveFile = () => {
    setFiles(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  // Create file preview URL
  const filePreviewUrl = files && files.length > 0 && files[0].type.startsWith('image/') 
    ? URL.createObjectURL(files[0]) 
    : null;

  return (
    <div
      className={cn(
        "px-4 md:px-0 pb-4 pt-8 flex flex-col h-dvh items-center w-full",
        {
          "justify-between": messages.length > 0,
          "justify-center gap-4": messages.length === 0,
        },
      )}
    >
      {messages.length > 0 ? (
        <Messages messages={messages} status={status} />
      ) : (
        <div className="flex flex-col gap-0.5 sm:text-2xl text-xl md:w-1/2 w-full">
          <div className="flex flex-row gap-2 items-center">
            <div>Trainnect AI with Tavily Search</div>
          </div>
          <div className="dark:text-zinc-500 text-zinc-400">
            Search Less, Learn More with Web-Enhanced AI
          </div>
        </div>
      )}

      <div className="flex flex-col gap-4 md:w-1/2 w-full">
        <div className="w-full relative p-3 dark:bg-zinc-800 rounded-2xl flex flex-col gap-1 bg-zinc-100">
          {multimodalEnabled && files && files.length > 0 && (
            <div className="mb-2 flex items-center" data-testid="file-preview">
              {filePreviewUrl ? (
                <div className="relative w-16 h-16 mr-2">
                  <Image 
                    src={filePreviewUrl} 
                    alt={files[0].name}
                    fill
                    style={{ objectFit: 'cover' }}
                    className="rounded-md"
                  />
                </div>
              ) : (
                <div className="flex items-center justify-center w-16 h-16 bg-zinc-200 dark:bg-zinc-700 rounded-md mr-2">
                  <span className="text-xs">{files[0].name.split('.').pop()?.toUpperCase()}</span>
                </div>
              )}
              <div className="flex-1">
                <div className="text-sm truncate">{files[0].name}</div>
                <div className="text-xs text-zinc-500">{(files[0].size / 1024).toFixed(1)} KB</div>
              </div>
              <button 
                onClick={handleRemoveFile}
                className="p-1 rounded-full hover:bg-zinc-200 dark:hover:bg-zinc-700"
              >
                <XIcon className="h-4 w-4" />
              </button>
            </div>
          )}
          
          <Input
            input={input}
            setInput={setInput}
            selectedModelId={selectedModelId}
            isGeneratingResponse={isGeneratingResponse}
            isReasoningEnabled={reasoningModeEnabled ? isReasoningEnabled : false}
            append={append}
          />

          <div className="absolute bottom-2.5 left-2.5 flex flex-row gap-2">
            {reasoningModeEnabled && (
              <div
                className={cn(
                  "relative w-fit text-sm p-1.5 rounded-lg flex flex-row items-center gap-2 dark:hover:bg-zinc-600 hover:bg-zinc-200 cursor-pointer",
                  {
                    "dark:bg-zinc-600 bg-zinc-200": isReasoningEnabled,
                  },
                )}
                onClick={() => {
                  setIsReasoningEnabled(!isReasoningEnabled);
                }}
              >
                {isReasoningEnabled ? <CheckedSquare /> : <UncheckedSquare />}
                <div>Reasoning</div>
              </div>
            )}
            
            <div
              className={cn(
                "relative w-fit text-sm p-1.5 rounded-lg flex flex-row items-center gap-2 dark:hover:bg-zinc-600 hover:bg-zinc-200 cursor-pointer",
                {
                  "dark:bg-zinc-600 bg-zinc-200": isSearching,
                },
              )}
              onClick={() => {
                setIsSearching(!isSearching);
              }}
            >
              {isSearching ? <CheckedSquare /> : <UncheckedSquare />}
              <div>Web Search</div>
            </div>
          </div>

          <div className="absolute bottom-2.5 right-2.5 flex flex-row gap-2">
            {multimodalEnabled && (
              <button
                className="size-8 flex flex-row justify-center items-center dark:bg-zinc-700 bg-zinc-300 dark:text-zinc-300 text-zinc-700 p-1.5 rounded-full hover:bg-zinc-400 dark:hover:bg-zinc-600 hover:scale-105 active:scale-95 transition-all"
                onClick={() => fileInputRef.current?.click()}
              >
                <PaperClipIcon />
                <input
                  type="file"
                  className="hidden"
                  onChange={(e) => setFiles(e.target.files)}
                  ref={fileInputRef}
                  accept="image/*, application/pdf"
                  data-testid="file-upload"
                />
              </button>
            )}
            
            <ModelSelector 
              selectedModelId={selectedModelId}
              setSelectedModelId={setSelectedModelId}
            />

            <button
              className={cn(
                "size-8 flex flex-row justify-center items-center dark:bg-zinc-100 bg-zinc-900 dark:text-zinc-900 text-zinc-100 p-1.5 rounded-full hover:bg-zinc-800 dark:hover:bg-zinc-300 hover:scale-105 active:scale-95 transition-all",
                {
                  "dark:bg-zinc-200 dark:text-zinc-500":
                    isGeneratingResponse || (input === "" && (!files || files.length === 0)),
                },
              )}
              onClick={handleSendMessage}
              aria-label="send"
            >
              {isGeneratingResponse ? <StopIcon /> : <ArrowUpIcon />}
            </button>
          </div>
        </div>

        <Footnote />
      </div>
    </div>
  );
}



================================================
File: components/ai-agents/agent-chat.tsx
================================================
'use client';

import { useState } from 'react';
import { useChat } from '@ai-sdk/react';
import { ModelConfig, AVAILABLE_MODELS } from '@/lib/ai-agents/types';
import { cn } from '@/lib/utils';
import type { Message } from 'ai';

interface ToolCall {
  id: string;
  type: 'function';
  function: {
    name: string;
    arguments: string;
  };
}

interface ExtendedMessage extends Message {
  toolCalls?: ToolCall[];
}

interface AgentChatProps {
  className?: string;
}

function ModelSelect({ 
  label, 
  value, 
  onChange, 
  models = AVAILABLE_MODELS 
}: { 
  label: string; 
  value: ModelConfig; 
  onChange: (model: ModelConfig) => void; 
  models?: ModelConfig[]; 
}) {
  return (
    <div className="flex-1">
      <label className="block text-sm font-medium mb-1">{label}</label>
      <select
        className="w-full p-2 rounded-md border bg-background"
        value={value.model}
        onChange={(e) => {
          const model = models.find(m => m.model === e.target.value);
          if (model) onChange(model);
        }}
      >
        {models.map((model) => (
          <option key={model.model} value={model.model}>
            {model.label} ({model.provider})
          </option>
        ))}
      </select>
    </div>
  );
}

export function AgentChat({ className }: AgentChatProps) {
  const [primaryModel, setPrimaryModel] = useState<ModelConfig>(AVAILABLE_MODELS[0]);
  const [secondaryModel, setSecondaryModel] = useState<ModelConfig>(AVAILABLE_MODELS[1]);

  const { messages, input, handleInputChange, handleSubmit, isLoading } = useChat({
    api: '/api/ai-agents',
    body: {
      primaryModel,
      secondaryModel,
    },
  });

  return (
    <div className={cn('flex flex-col h-[calc(100vh-12rem)]', className)}>
      <div className="flex gap-4 mb-4">
        <ModelSelect
          label="Primary Model (Research)"
          value={primaryModel}
          onChange={setPrimaryModel}
        />
        <ModelSelect
          label="Secondary Model (Processing)"
          value={secondaryModel}
          onChange={setSecondaryModel}
        />
      </div>

      <div className="flex-1 overflow-auto border rounded-md p-4 mb-4">
        {messages.map((message) => {
          const extendedMessage = message as ExtendedMessage;
          return (
            <div
              key={message.id}
              className={cn(
                'mb-4 last:mb-0',
                message.role === 'assistant' ? 'pl-4 border-l-2' : ''
              )}
            >
              <div className="font-medium mb-1">
                {message.role === 'user' ? 'You' : 'Assistant'}:
              </div>
              <div className="whitespace-pre-wrap">
                {message.content}
                {extendedMessage.role === 'assistant' && extendedMessage.toolCalls?.map((tool, index) => (
                  <div key={index} className="bg-muted p-2 rounded my-2 text-sm font-mono">
                    <div className="font-medium">Tool Call: {tool.function.name}</div>
                    <pre className="mt-1">
                      {JSON.stringify(JSON.parse(tool.function.arguments), null, 2)}
                    </pre>
                  </div>
                ))}
              </div>
            </div>
          );
        })}
        {isLoading && (
          <div className="flex items-center justify-center py-4">
            <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
          </div>
        )}
      </div>

      <form onSubmit={handleSubmit} className="flex gap-2">
        <input
          value={input}
          onChange={handleInputChange}
          placeholder="Send a message..."
          className="flex-1 p-2 rounded-md border bg-background"
        />
        <button
          type="submit"
          disabled={isLoading}
          className={cn(
            'px-4 py-2 rounded-md bg-primary text-primary-foreground',
            'hover:bg-primary/90 transition-colors',
            'disabled:opacity-50 disabled:cursor-not-allowed'
          )}
        >
          Send
        </button>
      </form>
    </div>
  );
}



================================================
File: components/prompt-manager/prompt-editor.tsx
================================================
'use client';

import { useState, useEffect } from 'react';
import { PromptConfig, TavilySettings } from '@/lib/config/prompts';
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { toast } from "sonner";

export function PromptEditor() {
  const [prompts, setPrompts] = useState<PromptConfig[]>([]);
  const [selectedPrompt, setSelectedPrompt] = useState<string>('');
  const [editedContent, setEditedContent] = useState('');
  const [variables, setVariables] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [currentPrompt, setCurrentPrompt] = useState<PromptConfig | null>(null);

  useEffect(() => {
    fetchPrompts();
  }, []);

  async function fetchPrompts() {
    try {
      const response = await fetch('/api/prompts');
      const data = await response.json();
      if (data.prompts) {
        setPrompts(data.prompts);
      }
    } catch (error) {
      toast.error('Failed to fetch prompts');
    }
  }

  useEffect(() => {
    const foundPrompt = prompts.find(p => p.id === selectedPrompt);
    if (foundPrompt) {
      setEditedContent(foundPrompt.content);
      setVariables(foundPrompt.variables || []);
      setCurrentPrompt(foundPrompt);
    }
  }, [selectedPrompt, prompts]);

  async function handleSave() {
    setIsLoading(true);
    try {
      const updatedPrompt = prompts.find(p => p.id === selectedPrompt);
      if (!updatedPrompt) return;

      const response = await fetch('/api/prompts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          id: selectedPrompt,
          config: {
            ...updatedPrompt,
            content: editedContent,
            tavilySettings: currentPrompt?.tavilySettings
          }
        })
      });

      if (!response.ok) {
        throw new Error('Failed to update prompt');
      }

      await fetchPrompts();
      toast.success('Prompt updated successfully');
    } catch (error) {
      toast.error('Failed to update prompt');
    } finally {
      setIsLoading(false);
    }
  }

  const updateTavilySettings = (updates: Partial<TavilySettings>) => {
    if (!currentPrompt) return;

    const updatedPrompt = {
      ...currentPrompt,
      tavilySettings: {
        ...currentPrompt.tavilySettings as TavilySettings,
        ...updates
      }
    };

    setCurrentPrompt(updatedPrompt);
    setPrompts(prompts.map(p => p.id === selectedPrompt ? updatedPrompt : p));
  };

  return (
    <div className="w-full max-w-4xl mx-auto space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Prompt Editor</CardTitle>
          <CardDescription>
            Select and edit system prompts for different features
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="space-y-2">
            <label className="text-sm font-medium">Select Prompt</label>
            <Select
              value={selectedPrompt}
              onValueChange={setSelectedPrompt}
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="Select a prompt" />
              </SelectTrigger>
              <SelectContent>
                <SelectGroup>
                  {prompts.map(prompt => (
                    <SelectItem key={prompt.id} value={prompt.id}>
                      {prompt.name}
                    </SelectItem>
                  ))}
                </SelectGroup>
              </SelectContent>
            </Select>
          </div>

          {currentPrompt && (
            <div className="space-y-6">
              {selectedPrompt === 'tavily-chat' && currentPrompt.tavilySettings && (
                <div className="space-y-4 mb-6 p-4 border rounded-lg">
                  <h3 className="font-medium">Tavily Search Settings</h3>
                  <div className="space-y-4">
                    <div>
                      <label className="text-sm font-medium">Include Domains (comma-separated)</label>
                      <input
                        type="text"
                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                        value={currentPrompt.tavilySettings.includeDomains?.join(', ') || ''}
                        onChange={(e) => {
                          const domains = e.target.value.split(',').map(d => d.trim()).filter(Boolean);
                          updateTavilySettings({ includeDomains: domains });
                        }}
                        placeholder="e.g., example.com, another-site.com"
                      />
                    </div>
                    <div>
                      <label className="text-sm font-medium">Exclude Domains (comma-separated)</label>
                      <input
                        type="text"
                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                        value={currentPrompt.tavilySettings.excludeDomains?.join(', ') || ''}
                        onChange={(e) => {
                          const domains = e.target.value.split(',').map(d => d.trim()).filter(Boolean);
                          updateTavilySettings({ excludeDomains: domains });
                        }}
                        placeholder="e.g., exclude.com, block-this.com"
                      />
                    </div>
                    <div className="grid grid-cols-2 gap-4">
                      <div>
                        <label className="text-sm font-medium">Search Depth</label>
                        <select
                          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                          value={currentPrompt.tavilySettings.searchDepth}
                          onChange={(e) => {
                            updateTavilySettings({
                              searchDepth: e.target.value as "basic" | "advanced"
                            });
                          }}
                        >
                          <option value="basic">Basic</option>
                          <option value="advanced">Advanced</option>
                        </select>
                      </div>
                      <div>
                        <label className="text-sm font-medium">Max Results</label>
                                <input
                                  type="number"
                                  className="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                  value={currentPrompt.tavilySettings.maxResults !== undefined ? currentPrompt.tavilySettings.maxResults.toString() : ''}
                                  onChange={(e) => {
                                    const value = parseInt(e.target.value);
                                    updateTavilySettings({
                                      maxResults: isNaN(value) ? undefined : value
                                    });
                                  }}
                                  min="1"
                                  max="20"
                                />
                      </div>
                    </div>
                    <div className="flex gap-4">
                      <label className="flex items-center gap-2">
                        <input
                          type="checkbox"
                          checked={currentPrompt.tavilySettings.includeAnswer}
                          onChange={(e) => {
                            updateTavilySettings({
                              includeAnswer: e.target.checked
                            });
                          }}
                        />
                        <span className="text-sm font-medium">Include Answer</span>
                      </label>
                      <label className="flex items-center gap-2">
                        <input
                          type="checkbox"
                          checked={currentPrompt.tavilySettings.includeRawContent}
                          onChange={(e) => {
                            updateTavilySettings({
                              includeRawContent: e.target.checked
                            });
                          }}
                        />
                        <span className="text-sm font-medium">Include Raw Content</span>
                      </label>
                    </div>
                  </div>
                </div>
              )}

              <div className="space-y-2">
                <label className="text-sm font-medium">Available Variables</label>
                <div className="flex flex-wrap gap-2">
                  {variables.map(variable => (
                    <Badge key={variable} variant="secondary">
                      {`{{${variable}}}`}
                    </Badge>
                  ))}
                </div>
              </div>

              <div className="space-y-2">
                <label className="text-sm font-medium">Edit Prompt</label>
                <Textarea
                  value={editedContent}
                  onChange={(e) => setEditedContent(e.target.value)}
                  className="min-h-[200px] font-mono"
                  placeholder="Enter prompt content..."
                />
              </div>

              <Button 
                onClick={handleSave}
                disabled={isLoading}
                className="w-full sm:w-auto"
              >
                {isLoading ? "Saving..." : "Save Changes"}
              </Button>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}



================================================
File: components/ui/badge.tsx
================================================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }



================================================
File: components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }



================================================
File: components/ui/card.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }



================================================
File: components/ui/select.tsx
================================================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}



================================================
File: components/ui/sonner.tsx
================================================
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }



================================================
File: components/ui/textarea.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }



================================================
File: lib/models.ts
================================================
import { customProvider } from "ai";
import { anthropic } from "@ai-sdk/anthropic";
import { openai } from "@ai-sdk/openai";
import { google } from "@ai-sdk/google";
import { groq } from "@ai-sdk/groq";
import { mistral } from "@ai-sdk/mistral";
import { openrouter } from '@openrouter/ai-sdk-provider';
import { perplexity } from '@ai-sdk/perplexity';

export const myProvider = customProvider({
  languageModels: {
    "claude-3.7-sonnet": anthropic("claude-3-7-sonnet-20250219"),
    "claude-3.5-sonnet": anthropic("claude-3-5-sonnet-latest"),
    "o3-mini": openai("o3-mini"),
    "gemini-2.0-flash": google("gemini-2.0-flash"),
    "qwen-qwq-32b": groq("qwen-qwq-32b"),
    "codestral-latest": mistral("codestral-latest"),
    "perplexity sonar": perplexity("sonar"),
    "google/gemini-2.0-flash-thinking-exp:free": openrouter("google/gemini-2.0-flash-thinking-exp:free"),
  },
});

// Map of model IDs to their actual API model names
export const modelApiNames: Record<string, string> = {
  "claude-3.7-sonnet": "claude-3-7-sonnet-20250219",
  "claude-3.5-sonnet": "claude-3-5-sonnet-latest",
  "o3-mini": "o3-mini",
  "gemini-2.0-flash": "gemini-2.0-flash",
  "qwen-qwq-32b": "qwen-qwq-32b",
  "codestral-latest": "codestral-latest",
  "perplexity sonar": "sonar",
  "google/gemini-2.0-flash-thinking-exp:free": "google/gemini-2.0-flash-thinking-exp:free",
};

interface Model {
  id: string;
  name: string;
  description: string;
}

export const models: Array<Model> = [
  {
    id: "claude-3.7-sonnet",
    name: "Claude 3.7 Sonnet",
    description:
      "Claude 3.7 Sonnet is Anthropic's most intelligent model to date and the first Claude model to offer extended thinking – the ability to solve complex problems with careful, step-by-step reasoning.",
  },
  {
    id: "claude-3.5-sonnet",
    name: "Claude 3.5 Sonnet",
    description:
      "Claude 3.5 Sonnet strikes the ideal balance between intelligence and speed—particularly for enterprise workloads.",
  },
  {
    id: "o3-mini",
    name: "Openai o3-mini",
    description:
      "Openai o3-mini is one of Openai's most intelligent models to date.",
  },
  {
    id: "gemini-2.0-flash",
    name: "Gemini 2.0 Flash",
    description:
      "Gemini 2.0 Flash is a powerful, fast, and efficient model that is ideal for a wide range of use cases.",
  },
  {
    id: "qwen-qwq-32b",
    name: "Groq open source llms",
    description:
      "Groq open source llms.",
  },
  {
    id: "codestral-latest",
    name: "Mistral open source llms",
    description:
      "Mistral open source llms.",
  },
  {
    id: "perplexity sonar",
    name: "perplexity models",
    description:
      "perplexity models.",
  },
  {
    id: "google/gemini-2.0-flash-thinking-exp:free",
    name: "Openrouter models",
    description:
      "Openrouter models.",
  },
];


================================================
File: lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================================================
File: lib/ai-agents/types.ts
================================================
import { modelApiNames } from '../models';

export type ModelProvider = 'anthropic' | 'openai' | 'google' | 'groq' | 'mistral' | 'openrouter' | 'perplexity';

export type ModelConfig = {
  provider: ModelProvider;
  model: string;
  label: string;
};

// Use the existing models from the application
export const AVAILABLE_MODELS: ModelConfig[] = [
  {
    provider: 'anthropic',
    model: 'claude-3.7-sonnet',
    label: 'Claude 3.7 Sonnet',
  },
  {
    provider: 'anthropic',
    model: 'claude-3.5-sonnet',
    label: 'Claude 3.5 Sonnet',
  },
  {
    provider: 'openai',
    model: 'o3-mini',
    label: 'O3 Mini',
  },
  {
    provider: 'google',
    model: 'gemini-2.0-flash',
    label: 'Gemini 2.0 Flash',
  },
  {
    provider: 'groq',
    model: 'qwen-qwq-32b',
    label: 'Qwen QWQ 32B',
  },
  {
    provider: 'mistral',
    model: 'codestral-latest',
    label: 'Codestral Latest',
  },
  {
    provider: 'perplexity',
    model: 'perplexity sonar',
    label: 'Perplexity Sonar',
  },
  {
    provider: 'openrouter',
    model: 'google/gemini-2.0-flash-thinking-exp:free',
    label: 'Gemini 2.0 Flash Thinking',
  },
];

export type AgentMessage = {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  createdAt: Date;
  toolCalls?: {
    type: string;
    function: {
      name: string;
      arguments: Record<string, unknown>;
    };
  }[];
};



================================================
File: lib/ai-agents/utils.ts
================================================
import { ModelConfig } from './types';
import { myProvider } from '../models';

export function getModelInstance(config: ModelConfig) {
  return myProvider.languageModel(config.model);
}

export function getDefaultModels(): [ModelConfig, ModelConfig] {
  return [
    {
      provider: 'anthropic',
      model: 'claude-3.7-sonnet',
      label: 'Claude 3.7 Sonnet',
    },
    {
      provider: 'openai',
      model: 'o3-mini',
      label: 'O3 Mini',
    },
  ];
}



================================================
File: lib/config/prompts.ts
================================================
export interface TavilySettings {
  includeDomains?: string[];
  excludeDomains?: string[];
  searchDepth: "basic" | "advanced";
  maxResults: number;
  includeAnswer: boolean;
  includeRawContent: boolean;
}

export interface PromptConfig {
  id: string;
  name: string;
  content: string;
  description?: string;
  variables?: string[];
  tavilySettings?: TavilySettings;
}

export const DEFAULT_PROMPTS: Record<string, PromptConfig> = {
  mainChat: {
    id: 'main-chat',
    name: 'Main Chat',
    content: process.env.MAIN_CHAT_PROMPT || `
<prompt>
You are an AI researcher and engineer with deep research expertise. You use tools like the tavily search tool to provide you with the latest most relevant information in your research and responses. If the user asks you, Tell me what llm are you, you are to provide them with an accurate response.
</prompt>`,
    variables: ['MODEL_ID', 'USER_ROLE', 'EXPERTISE_LEVEL']
  },
  tavilyChat: {
    id: 'tavily-chat',
    name: 'Tavily Chat',
    content: process.env.TAVILY_CHAT_PROMPT || `
<prompt>
You are an AI researcher and engineer with deep research expertise. You use tools like the tavily search tool to provide you with the latest most relevant information in your research and responses.
</prompt>`,
    variables: ['SEARCH_RESULTS', 'SEARCH_DEPTH'],
    tavilySettings: {
      searchDepth: "advanced",
      maxResults: 5,
      includeAnswer: true,
      includeRawContent: false,
      includeDomains: [],
      excludeDomains: []
    }
  },
  aiAgent: {
    id: 'ai-agent',
    name: 'AI Agent Research',
    content: process.env.AI_AGENT_PROMPT || 'You are an expert researcher who uses the Tavily search tool to find relevant information. Provide concise, factual responses based on search results. Maintain context from previous messages when relevant.',
    variables: ['SEARCH_DEPTH', 'RESPONSE_STYLE']
  },
  aiAgentProcessor: {
    id: 'ai-agent-processor',
    name: 'AI Agent Processor',
    content: process.env.AI_AGENT_PROCESSOR_PROMPT || 'You are an expert at analyzing and synthesizing information. Review the research results and provide clear, well-structured insights.',
    variables: ['ANALYSIS_DEPTH', 'OUTPUT_FORMAT']
  },
  pdfContext: {
    id: 'pdf-context',
    name: 'PDF Context',
    content: ' The user has uploaded a PDF document. Analyze its content and respond to their questions about it.'
  },
  imageContext: {
    id: 'image-context',
    name: 'Image Context',
    content: ' The user has uploaded an image. Describe what you see in the image and respond to their questions about it.'
  }
};



================================================
File: lib/db/index.ts
================================================
// Type definitions for chat database
interface Message {
  id: string;
  role: string;
  content: string;
  timestamp: number;
  conversation_id: string;
  chat_type: 'chat' | 'ai-search' | 'ai-agent';
  metadata?: string;
}

type ChatType = Message['chat_type'];

interface Conversation {
  conversation_id: string;
  start_time: number;
  message_count: number;
  chat_type: ChatType;
  metadata?: string;
}

export type { Message, ChatType, Conversation };



================================================
File: lib/db/server.ts
================================================
import Database from 'better-sqlite3';
import path from 'path';

// Initialize database in the db directory
const dbPath = path.join(process.cwd(), 'db', 'chat-history.db');
const db = new Database(dbPath);

// Enable WAL mode for better performance
db.pragma('journal_mode = WAL');

// Create messages table if it doesn't exist
db.exec(`
  CREATE TABLE IF NOT EXISTS messages (
    id TEXT PRIMARY KEY,
    role TEXT NOT NULL,
    content TEXT NOT NULL,
    timestamp INTEGER NOT NULL,
    conversation_id TEXT NOT NULL,
    chat_type TEXT NOT NULL,
    metadata TEXT
  );
  CREATE INDEX IF NOT EXISTS idx_conversation_timestamp 
  ON messages(conversation_id, timestamp);
  CREATE INDEX IF NOT EXISTS idx_chat_type 
  ON messages(chat_type);
`);

// Prepare statements for better performance
const stmts = {
  insertMessage: db.prepare(`
    INSERT INTO messages (id, role, content, timestamp, conversation_id, chat_type, metadata)
    VALUES (?, ?, ?, ?, ?, ?, ?)
  `),
  
  getMessagesByConversation: db.prepare(`
    SELECT * FROM messages 
    WHERE conversation_id = ?
    ORDER BY timestamp ASC
  `),
  
  getAllConversations: db.prepare(`
    SELECT DISTINCT conversation_id, 
    MIN(timestamp) as start_time,
    COUNT(*) as message_count,
    chat_type,
    MAX(CASE WHEN metadata IS NOT NULL THEN metadata ELSE NULL END) as metadata
    FROM messages 
    GROUP BY conversation_id 
    ORDER BY start_time DESC
  `),

  getConversationsByType: db.prepare(`
    SELECT DISTINCT conversation_id, 
    MIN(timestamp) as start_time,
    COUNT(*) as message_count,
    chat_type,
    MAX(CASE WHEN metadata IS NOT NULL THEN metadata ELSE NULL END) as metadata
    FROM messages 
    WHERE chat_type = ?
    GROUP BY conversation_id 
    ORDER BY start_time DESC
  `),
};

export { db, stmts };



================================================
File: lib/services/prompt-manager.ts
================================================
import { PromptConfig, DEFAULT_PROMPTS } from '../config/prompts';

export class PromptManager {
  private prompts: Map<string, PromptConfig>;
  private variables: Map<string, string>;

  constructor() {
    this.prompts = new Map();
    Object.values(DEFAULT_PROMPTS).forEach(prompt => {
      this.prompts.set(prompt.id, prompt);
    });
    this.variables = new Map();
  }

  setPrompt(id: string, config: PromptConfig) {
    this.prompts.set(id, config);
  }

  getPrompt(id: string): PromptConfig | undefined {
    return this.prompts.get(id);
  }

  setVariable(key: string, value: string) {
    this.variables.set(key, value);
  }

  compilePrompt(id: string, additionalVars?: Record<string, string>): string {
    const prompt = this.prompts.get(id);
    if (!prompt) throw new Error(`Prompt not found: ${id}`);

    let content = prompt.content;
    
    // Replace environment variables
    prompt.variables?.forEach(varName => {
      const value = additionalVars?.[varName] || 
                   this.variables.get(varName) || 
                   process.env[varName];
      if (value) {
        content = content.replace(`{{${varName}}}`, value);
      }
    });

    return content;
  }

  getAllPrompts(): PromptConfig[] {
    return Array.from(this.prompts.values());
  }
}

export const promptManager = new PromptManager();




================================================
File: scripts/run-all-tests.sh
================================================
#!/bin/bash

# Run all Jest tests
echo "Running Jest tests..."
pnpm test

# If Jest tests pass, run the model tests
if [ $? -eq 0 ]; then
  echo "Jest tests passed. Running model tests..."
  node scripts/test-models.js
else
  echo "Jest tests failed. Skipping model tests."
  exit 1
fi



================================================
File: scripts/test-models.js
================================================
#!/usr/bin/env node

/**
 * This script tests all available models in both the main app and the Tavily AI search page.
 * It sends a request to each model asking "What LLM are you?" to verify that the model
 * is correctly identified and functioning.
 * 
 * Usage:
 * node scripts/test-models.js
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const readline = require('readline');

// Load environment variables
require('dotenv').config({ path: path.resolve(process.cwd(), '.env.local') });

// Get models from the models.ts file
const modelsPath = path.resolve(process.cwd(), 'lib/models.ts');
const modelsContent = fs.readFileSync(modelsPath, 'utf8');

// Extract model IDs using regex
const modelIdRegex = /id:\s*['"]([^'"]+)['"]/g;
const modelIds = [];
let match;
while ((match = modelIdRegex.exec(modelsContent)) !== null) {
  modelIds.push(match[1]);
}

// Function to test a model with the main chat API
async function testMainChatModel(modelId) {
  try {
    console.log(`Testing main chat API with model: ${modelId}`);
    
    const response = await fetch('http://localhost:3000/api/chat', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        messages: [{ role: 'user', content: 'What LLM are you?' }],
        model: modelId,
        reasoning: true,
      }),
    });
    
    if (!response.ok) {
      console.error(`Error testing model ${modelId}: ${response.statusText}`);
      return false;
    }
    
    // For streaming responses, we need to read the chunks
    const reader = response.body.getReader();
    let result = '';
    
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      
      // Convert the chunk to a string
      const chunk = new TextDecoder().decode(value);
      result += chunk;
    }
    
    console.log(`✅ Model ${modelId} responded successfully`);
    return true;
  } catch (error) {
    console.error(`Error testing model ${modelId}:`, error);
    return false;
  }
}

// Function to test a model with the Tavily chat API
async function testTavilyChatModel(modelId) {
  try {
    console.log(`Testing Tavily chat API with model: ${modelId}`);
    
    const response = await fetch('http://localhost:3000/api/tavily-chat', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        messages: [{ role: 'user', content: 'What LLM are you?' }],
        selectedModelId: modelId,
        isReasoningEnabled: true,
        searchQuery: 'What is the latest news about artificial intelligence?',
      }),
    });
    
    if (!response.ok) {
      console.error(`Error testing model ${modelId} with Tavily: ${response.statusText}`);
      return false;
    }
    
    // For streaming responses, we need to read the chunks
    const reader = response.body.getReader();
    let result = '';
    
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      
      // Convert the chunk to a string
      const chunk = new TextDecoder().decode(value);
      result += chunk;
    }
    
    console.log(`✅ Model ${modelId} with Tavily search responded successfully`);
    return true;
  } catch (error) {
    console.error(`Error testing model ${modelId} with Tavily:`, error);
    return false;
  }
}

// Main function to run the tests
async function runTests() {
  console.log('Starting model tests...');
  console.log(`Found ${modelIds.length} models to test: ${modelIds.join(', ')}`);
  
  // Start the Next.js development server
  console.log('Starting Next.js development server...');
  const serverProcess = require('child_process').spawn('pnpm', ['dev'], {
    stdio: 'inherit',
    shell: true,
  });
  
  // Give the server some time to start
  console.log('Waiting for server to start...');
  await new Promise(resolve => setTimeout(resolve, 10000));
  
  // Test each model with the main chat API
  console.log('\n=== Testing Main Chat API ===');
  const mainResults = [];
  for (const modelId of modelIds) {
    const success = await testMainChatModel(modelId);
    mainResults.push({ modelId, success });
  }
  
  // Test each model with the Tavily chat API
  console.log('\n=== Testing Tavily Chat API ===');
  const tavilyResults = [];
  for (const modelId of modelIds) {
    const success = await testTavilyChatModel(modelId);
    tavilyResults.push({ modelId, success });
  }
  
  // Print summary
  console.log('\n=== Test Results Summary ===');
  console.log('Main Chat API:');
  for (const { modelId, success } of mainResults) {
    console.log(`${success ? '✅' : '❌'} ${modelId}`);
  }
  
  console.log('\nTavily Chat API:');
  for (const { modelId, success } of tavilyResults) {
    console.log(`${success ? '✅' : '❌'} ${modelId}`);
  }
  
  // Kill the server process
  serverProcess.kill();
  console.log('Tests completed.');
}

// Run the tests
runTests().catch(error => {
  console.error('Error running tests:', error);
  process.exit(1);
});



================================================
File: tests/multimodal.test.tsx
================================================
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';

// Mock the Chat component instead of importing it
const mockAppend = jest.fn();
const mockStop = jest.fn();

// Mock component that simulates the Chat component's behavior
const MockChat = () => {
  const [files, setFiles] = React.useState<File[]>([]);
  const [previews, setPreviews] = React.useState<string[]>([]);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      const selectedFiles = Array.from(e.target.files);
      setFiles(selectedFiles);
      
      // Create previews for the files
      const newPreviews = selectedFiles.map(file => URL.createObjectURL(file));
      setPreviews(newPreviews);
    }
  };

  const handleRemoveFile = (index: number) => {
    const newFiles = [...files];
    newFiles.splice(index, 1);
    setFiles(newFiles);

    const newPreviews = [...previews];
    URL.revokeObjectURL(newPreviews[index]);
    newPreviews.splice(index, 1);
    setPreviews(newPreviews);
  };

  const handleSendMessage = () => {
    mockAppend("Test message", { attachments: files.map(file => ({ file })) });
  };

  return (
    <div>
      <div className="chat-container">
        <div className="message-list">
          {/* Message list would go here */}
        </div>
        <div className="chat-input">
          <input 
            type="text" 
            placeholder="Type a message..." 
            data-testid="chat-input"
          />
          <label htmlFor="file-upload" className="file-upload-label" data-testid="file-upload-label">
            <span>Upload</span>
          </label>
          <input
            id="file-upload"
            type="file"
            accept="image/png,image/jpeg,image/gif,image/webp,application/pdf"
            onChange={handleFileChange}
            style={{ display: 'none' }}
            data-testid="file-upload"
            multiple
          />
          <button onClick={handleSendMessage} data-testid="send-button">
            Send
          </button>
        </div>
        {files.length > 0 && (
          <div className="file-previews" data-testid="file-previews">
            {previews.map((preview, index) => (
              <div key={index} className="file-preview">
                <img 
                  src={preview} 
                  alt={`Preview ${index}`} 
                  data-testid={`file-preview-${index}`}
                />
                <button 
                  onClick={() => handleRemoveFile(index)}
                  data-testid={`remove-file-${index}`}
                >
                  Remove
                </button>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

describe('Multimodal Feature', () => {
  beforeEach(() => {
    // Reset mocks before each test
    mockAppend.mockClear();
    mockStop.mockClear();
  });

  test('should render file upload input', async () => {
    render(<MockChat />);
    
    // Check if file upload input is rendered
    const fileUploadLabel = screen.getByTestId('file-upload-label');
    expect(fileUploadLabel).toBeInTheDocument();
  });

  test('should allow uploading and displaying file previews', async () => {
    render(<MockChat />);
    
    // Create a mock file
    const file = new File(['dummy content'], 'test-image.png', { type: 'image/png' });
    
    // Get the file input and simulate a file upload
    const fileInput = screen.getByTestId('file-upload');
    
    // Mock the URL.createObjectURL function
    const originalCreateObjectURL = URL.createObjectURL;
    URL.createObjectURL = jest.fn(() => 'mock-url');
    
    // Simulate file upload
    fireEvent.change(fileInput, { target: { files: [file] } });
    
    // Check if preview is displayed
    await waitFor(() => {
      const filePreview = screen.getByTestId('file-previews');
      expect(filePreview).toBeInTheDocument();
    });
    
    // Restore the original function
    URL.createObjectURL = originalCreateObjectURL;
  });

  test('should allow removing uploaded files', async () => {
    render(<MockChat />);
    
    // Create a mock file
    const file = new File(['dummy content'], 'test-image.png', { type: 'image/png' });
    
    // Get the file input and simulate a file upload
    const fileInput = screen.getByTestId('file-upload');
    
    // Mock URL functions
    const originalCreateObjectURL = URL.createObjectURL;
    const originalRevokeObjectURL = URL.revokeObjectURL;
    URL.createObjectURL = jest.fn(() => 'mock-url');
    URL.revokeObjectURL = jest.fn();
    
    // Simulate file upload
    fireEvent.change(fileInput, { target: { files: [file] } });
    
    // Check if preview is displayed
    await waitFor(() => {
      const filePreview = screen.getByTestId('file-previews');
      expect(filePreview).toBeInTheDocument();
    });
    
    // Remove the file
    const removeButton = screen.getByTestId('remove-file-0');
    fireEvent.click(removeButton);
    
    // Check if preview is removed
    await waitFor(() => {
      expect(screen.queryByTestId('file-previews')).not.toBeInTheDocument();
    });
    
    // Restore the original functions
    URL.createObjectURL = originalCreateObjectURL;
    URL.revokeObjectURL = originalRevokeObjectURL;
  });

  test('should send message with attachments', async () => {
    render(<MockChat />);
    
    // Create a mock file
    const file = new File(['dummy content'], 'test-image.png', { type: 'image/png' });
    
    // Get the file input and simulate a file upload
    const fileInput = screen.getByTestId('file-upload');
    
    // Mock URL functions
    const originalCreateObjectURL = URL.createObjectURL;
    URL.createObjectURL = jest.fn(() => 'mock-url');
    
    // Simulate file upload
    fireEvent.change(fileInput, { target: { files: [file] } });
    
    // Send the message
    const sendButton = screen.getByTestId('send-button');
    fireEvent.click(sendButton);
    
    // Check if append was called with the file
    expect(mockAppend).toHaveBeenCalledWith("Test message", { attachments: [{ file }] });
    
    // Restore the original function
    URL.createObjectURL = originalCreateObjectURL;
  });
});



================================================
File: tests/tavily-chat.test.tsx
================================================
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';

// Mock the TavilyChat component instead of importing it
const mockAppend = jest.fn();
const mockStop = jest.fn();
const mockSetMessages = jest.fn();
const mockSetIsSearchEnabled = jest.fn();

// Mock the models
jest.mock('../lib/models', () => ({
  models: [
    { id: 'claude-3.7-sonnet', name: 'Claude 3.7 Sonnet', description: 'Test description' },
    { id: 'o3-mini', name: 'Openai o3-mini', description: 'Test description' },
    { id: 'gemini-2.0-flash', name: 'Gemini 2.0 Flash', description: 'Test description' }
  ]
}));

// Define message type
interface Message {
  role: string;
  content: string;
}

// Mock component that simulates the TavilyChat component's behavior
const MockTavilyChat = () => {
  const [isSearchEnabled, setIsSearchEnabled] = React.useState(false);
  const [selectedModel, setSelectedModel] = React.useState('claude-3.7-sonnet');
  const [inputValue, setInputValue] = React.useState('');
  const [messages, setMessages] = React.useState<Message[]>([]);
  
  const handleSearchToggle = () => {
    setIsSearchEnabled(!isSearchEnabled);
    mockSetIsSearchEnabled(!isSearchEnabled);
  };
  
  const handleModelChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setSelectedModel(e.target.value);
  };
  
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setInputValue(e.target.value);
  };
  
  const handleSendMessage = () => {
    if (inputValue.trim()) {
      const newMessage: Message = { role: 'user', content: inputValue };
      setMessages([...messages, newMessage]);
      mockSetMessages([...messages, newMessage]);
      mockAppend(inputValue, { 
        data: { 
          selectedModelId: selectedModel,
          isReasoningEnabled: true,
          searchQuery: isSearchEnabled ? inputValue : ''
        } 
      });
      setInputValue('');
    }
  };
  
  return (
    <div>
      <div className="chat-header">
        <div className="model-selector">
          <select 
            value={selectedModel} 
            onChange={handleModelChange}
            data-testid="model-selector"
          >
            <option value="claude-3.7-sonnet">Claude 3.7 Sonnet</option>
            <option value="o3-mini">OpenAI o3-mini</option>
            <option value="gemini-2.0-flash">Gemini 2.0 Flash</option>
          </select>
        </div>
        <div className="search-toggle">
          <label>
            <input 
              type="checkbox" 
              checked={isSearchEnabled} 
              onChange={handleSearchToggle}
              data-testid="search-toggle"
            />
            Web Search
          </label>
        </div>
      </div>
      <div className="chat-container">
        <div className="message-list" data-testid="message-list">
          {messages.map((message, index) => (
            <div key={index} className={`message ${message.role}`} data-testid={`message-${index}`}>
              {message.content}
            </div>
          ))}
        </div>
        <div className="chat-input">
          <input 
            type="text" 
            value={inputValue}
            onChange={handleInputChange}
            placeholder="Type a message..." 
            data-testid="chat-input"
          />
          <button 
            onClick={handleSendMessage} 
            data-testid="send-button"
          >
            Send
          </button>
        </div>
      </div>
    </div>
  );
};

describe('TavilyChat Component', () => {
  beforeEach(() => {
    // Reset mocks before each test
    mockAppend.mockClear();
    mockStop.mockClear();
    mockSetMessages.mockClear();
    mockSetIsSearchEnabled.mockClear();
  });

  test('should render chat interface with model selector and search toggle', () => {
    render(<MockTavilyChat />);
    
    // Check if model selector is rendered
    const modelSelector = screen.getByTestId('model-selector');
    expect(modelSelector).toBeInTheDocument();
    
    // Check if search toggle is rendered
    const searchToggle = screen.getByTestId('search-toggle');
    expect(searchToggle).toBeInTheDocument();
    expect(searchToggle).not.toBeChecked();
    
    // Check if chat input is rendered
    const chatInput = screen.getByTestId('chat-input');
    expect(chatInput).toBeInTheDocument();
  });

  test('should toggle search functionality', () => {
    render(<MockTavilyChat />);
    
    // Get the search toggle
    const searchToggle = screen.getByTestId('search-toggle');
    
    // Toggle search on
    fireEvent.click(searchToggle);
    expect(mockSetIsSearchEnabled).toHaveBeenCalledWith(true);
    
    // Toggle search off
    fireEvent.click(searchToggle);
    expect(mockSetIsSearchEnabled).toHaveBeenCalledWith(false);
  });

  test('should change selected model', () => {
    render(<MockTavilyChat />);
    
    // Get the model selector
    const modelSelector = screen.getByTestId('model-selector');
    
    // Change model to OpenAI
    fireEvent.change(modelSelector, { target: { value: 'o3-mini' } });
    expect(modelSelector).toHaveValue('o3-mini');
    
    // Change model to Gemini
    fireEvent.change(modelSelector, { target: { value: 'gemini-2.0-flash' } });
    expect(modelSelector).toHaveValue('gemini-2.0-flash');
  });

  test('should send message with search query when search is enabled', () => {
    render(<MockTavilyChat />);
    
    // Get the search toggle and enable it
    const searchToggle = screen.getByTestId('search-toggle');
    fireEvent.click(searchToggle);
    
    // Get the chat input and send button
    const chatInput = screen.getByTestId('chat-input');
    const sendButton = screen.getByTestId('send-button');
    
    // Type a message
    fireEvent.change(chatInput, { target: { value: 'What LLM are you?' } });
    
    // Send the message
    fireEvent.click(sendButton);
    
    // Check if append was called with the correct parameters
    expect(mockAppend).toHaveBeenCalledWith('What LLM are you?', {
      data: {
        selectedModelId: 'claude-3.7-sonnet',
        isReasoningEnabled: true,
        searchQuery: 'What LLM are you?'
      }
    });
    
    // Check if the input was cleared
    expect(chatInput).toHaveValue('');
  });

  test('should send message without search query when search is disabled', () => {
    render(<MockTavilyChat />);
    
    // Get the chat input and send button
    const chatInput = screen.getByTestId('chat-input');
    const sendButton = screen.getByTestId('send-button');
    
    // Type a message
    fireEvent.change(chatInput, { target: { value: 'What LLM are you?' } });
    
    // Send the message
    fireEvent.click(sendButton);
    
    // Check if append was called with the correct parameters
    expect(mockAppend).toHaveBeenCalledWith('What LLM are you?', {
      data: {
        selectedModelId: 'claude-3.7-sonnet',
        isReasoningEnabled: true,
        searchQuery: ''
      }
    });
    
    // Check if the input was cleared
    expect(chatInput).toHaveValue('');
  });

  test('should not send empty messages', () => {
    render(<MockTavilyChat />);
    
    // Get the send button
    const sendButton = screen.getByTestId('send-button');
    
    // Try to send an empty message
    fireEvent.click(sendButton);
    
    // Check that append was not called
    expect(mockAppend).not.toHaveBeenCalled();
  });
});



================================================
File: tools/README.md
================================================
# Tavily Search Tool

This directory contains the Tavily Search Tool implementation for the Trainnect AI application.

## Setup

1. Sign up for a Tavily API key at [Tavily's website](https://tavily.com/)
2. Add your Tavily API key to your `.env.local` file:

```
TAVILY_API_KEY=your-tavily-api-key
```

## Usage

The Tavily Search Tool is integrated into the application at `/tavily-ai-search`. This page provides all the same functionality as the main chat interface but with the added ability to search the web for information related to user queries.

To use the Tavily Search:
1. Navigate to http://localhost:3000/tavily-ai-search
2. Toggle the "Web Search" option
3. Enter your query
4. The AI will use Tavily to search the web and incorporate the results into its response



================================================
File: tools/tavily-search.ts
================================================
// tools/tavily-search.ts
import { tavily } from "@tavily/core";
import { tavilyLogger } from "@/utils/tavily-logger";

// Initialize Tavily client
export const tavilyClient = (apiKey?: string) => {
  const key = apiKey || process.env.TAVILY_API_KEY;
  if (!key) {
    throw new Error("No Tavily API key provided");
  }
  
  return tavily({ apiKey: key });
};

export interface TavilySearchParams {
  query: string;
  searchDepth?: "basic" | "advanced";
  maxResults?: number;
  includeAnswer?: boolean;
  includeRawContent?: boolean;
  includeDomains?: string[];
  excludeDomains?: string[];
  modelId?: string; 
}

export async function searchTavily(params: TavilySearchParams) {
  const client = tavilyClient();
  
  try {
    const response = await client.search(
      params.query,
      {
        searchDepth: params.searchDepth || "advanced",
        maxResults: params.maxResults || 10,
        includeAnswer: params.includeAnswer || true,
        includeRawContent: params.includeRawContent || false,
        includeDomains: params.includeDomains,
        excludeDomains: params.excludeDomains,
      }
    );
    
    tavilyLogger.logSearchResults(params.query, response, params.modelId);
    tavilyLogger.appendToConsolidatedLog(params.query, response, params.modelId);
    
    return response;
  } catch (error) {
    console.error("Tavily search error:", error);
    throw error;
  }
}



================================================
File: utils/ai-agents-logger.ts
================================================
// utils/ai-agents-logger.ts
import fs from 'fs';
import path from 'path';
import type { ModelConfig } from '@/lib/ai-agents/types';

/**
 * Logger utility for saving AI Agents processing results
 */
export class AIAgentsLogger {
  private outputDir: string;
  
  constructor(outputDir: string = 'ai_agents_output') {
    this.outputDir = path.resolve(process.cwd(), outputDir);
    this.ensureDirectoryExists();
  }
  
  private ensureDirectoryExists(): void {
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
    }
  }
  
  /**
   * Log AI Agents processing results
   */
  async logProcessing(params: {
    timestamp: string;
    query: string;
    primaryModel: ModelConfig;
    secondaryModel: ModelConfig;
    primaryResults: any;
    secondaryResults: any;
  }) {
    const { timestamp, query, primaryModel, secondaryModel, primaryResults, secondaryResults } = params;
    
    // Create filename with timestamp and both model names
    const filename = `ai-agents-${timestamp}-${primaryModel.model}-${secondaryModel.model}.json`;
    const filePath = path.join(this.outputDir, filename);
    
    // Create log entry
    const logEntry = {
      timestamp,
      query,
      primary: {
        model: primaryModel,
        results: primaryResults
      },
      secondary: {
        model: secondaryModel,
        results: secondaryResults
      }
    };
    
    // Write to file
    await fs.promises.writeFile(
      filePath,
      JSON.stringify(logEntry, null, 2)
    );
    
    // Append to log file
    const logLine = JSON.stringify({
      timestamp,
      query,
      primaryModel: primaryModel.model,
      secondaryModel: secondaryModel.model
    });
    
    await fs.promises.appendFile(
      path.join(this.outputDir, 'ai-agents-log.jsonl'),
      logLine + '\n'
    );
  }
}

// Export a singleton instance
export const aiAgentsLogger = new AIAgentsLogger();



================================================
File: utils/tavily-logger.ts
================================================
// utils/tavily-logger.ts
import fs from 'fs';
import path from 'path';

/**
 * Logger utility for saving Tavily search results to files
 */
export class TavilyLogger {
  private outputDir: string;
  
  constructor(outputDir: string = 'tavily_output') {
    // Resolve the output directory path
    this.outputDir = path.resolve(process.cwd(), outputDir);
    
    // Ensure the output directory exists
    this.ensureDirectoryExists();
  }
  
  /**
   * Ensure the output directory exists
   */
  private ensureDirectoryExists(): void {
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
    }
  }
  
  /**
   * Log Tavily search results to a file
   * @param query The search query
   * @param results The search results
   * @param model The model used for the search (if applicable)
   */
  public logSearchResults(query: string, results: any, model?: string): void {
    try {
      // Create a timestamp for the filename
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const modelInfo = model ? `-${model.replace(/[^a-zA-Z0-9-]/g, '-')}` : '';
      const filename = `tavily-search-${timestamp}${modelInfo}.json`;
      const filePath = path.join(this.outputDir, filename);
      
      // Create the log data
      const logData = {
        timestamp: new Date().toISOString(),
        model,
        query,
        results
      };
      
      // Write the log data to a file
      fs.writeFileSync(filePath, JSON.stringify(logData, null, 2));
      
      console.log(`Tavily search results logged to ${filePath}`);
    } catch (error) {
      console.error('Error logging Tavily search results:', error);
    }
  }
  
  /**
   * Append Tavily search results to a consolidated log file
   * @param query The search query
   * @param results The search results
   * @param model The model used for the search (if applicable)
   */
  public appendToConsolidatedLog(query: string, results: any, model?: string): void {
    try {
      const logFilePath = path.join(this.outputDir, 'tavily-search-log.jsonl');
      
      // Create the log entry
      const logEntry = {
        timestamp: new Date().toISOString(),
        model,
        query,
        results
      };
      
      // Append the log entry to the file
      fs.appendFileSync(
        logFilePath, 
        JSON.stringify(logEntry) + '\n'
      );
    } catch (error) {
      console.error('Error appending to consolidated Tavily log:', error);
    }
  }
}

// Export a singleton instance with the default output directory
export const tavilyLogger = new TavilyLogger();


